// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionCesiumRTCJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionCesiumRTC.h>
#include <CesiumGltfReader/ExtensionCesiumRTCReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionCesiumRTCJsonHandler::ExtensionCesiumRTCJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options), _center() {}

void ExtensionCesiumRTCJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionCesiumRTC* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionCesiumRTCJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionCesiumRTC(
      CesiumGltf::ExtensionCesiumRTC::TypeName,
      str,
      *this->_pObject);
}

void ExtensionCesiumRTCJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions.emplace(extensionName, CesiumGltf::ExtensionCesiumRTC())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionCesiumRTC&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionCesiumRTCJsonHandler::readObjectKeyExtensionCesiumRTC(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ExtensionCesiumRTC& o) {
  using namespace std::string_literals;

  if ("center"s == str)
    return property("center", this->_center, o.center);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionCesiumRTCReader::ExtensionCesiumRTCReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& ExtensionCesiumRTCReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionCesiumRTCReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionCesiumRTC>
ExtensionCesiumRTCReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionCesiumRTCJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionCesiumRTC>
ExtensionCesiumRTCReader::readFromJson(const rapidjson::Value& value) const {
  ExtensionCesiumRTCJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::ExtensionCesiumRTC>>
ExtensionCesiumRTCReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionCesiumRTC,
      ExtensionCesiumRTCJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionCesiumTileEdgesJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionCesiumTileEdges.h>
#include <CesiumGltfReader/ExtensionCesiumTileEdgesReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionCesiumTileEdgesJsonHandler::ExtensionCesiumTileEdgesJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _left(),
      _bottom(),
      _right(),
      _top() {}

void ExtensionCesiumTileEdgesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionCesiumTileEdges* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionCesiumTileEdgesJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionCesiumTileEdges(
      CesiumGltf::ExtensionCesiumTileEdges::TypeName,
      str,
      *this->_pObject);
}

void ExtensionCesiumTileEdgesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionCesiumTileEdges())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionCesiumTileEdges&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionCesiumTileEdgesJsonHandler::readObjectKeyExtensionCesiumTileEdges(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ExtensionCesiumTileEdges& o) {
  using namespace std::string_literals;

  if ("left"s == str)
    return property("left", this->_left, o.left);
  if ("bottom"s == str)
    return property("bottom", this->_bottom, o.bottom);
  if ("right"s == str)
    return property("right", this->_right, o.right);
  if ("top"s == str)
    return property("top", this->_top, o.top);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionCesiumTileEdgesReader::ExtensionCesiumTileEdgesReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionCesiumTileEdgesReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionCesiumTileEdgesReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionCesiumTileEdges>
ExtensionCesiumTileEdgesReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionCesiumTileEdgesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionCesiumTileEdges>
ExtensionCesiumTileEdgesReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionCesiumTileEdgesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionCesiumTileEdges>>
ExtensionCesiumTileEdgesReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionCesiumTileEdges,
      ExtensionCesiumTileEdgesJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionModelExtFeatureMetadataJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionModelExtFeatureMetadata.h>
#include <CesiumGltfReader/ExtensionModelExtFeatureMetadataReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionModelExtFeatureMetadataJsonHandler::
    ExtensionModelExtFeatureMetadataJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _schema(options),
      _schemaUri(),
      _statistics(options),
      _featureTables(options),
      _featureTextures(options) {}

void ExtensionModelExtFeatureMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionModelExtFeatureMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionModelExtFeatureMetadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionModelExtFeatureMetadata(
      CesiumGltf::ExtensionModelExtFeatureMetadata::TypeName,
      str,
      *this->_pObject);
}

void ExtensionModelExtFeatureMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            CesiumGltf::ExtensionModelExtFeatureMetadata())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionModelExtFeatureMetadata&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionModelExtFeatureMetadataJsonHandler::
    readObjectKeyExtensionModelExtFeatureMetadata(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionModelExtFeatureMetadata& o) {
  using namespace std::string_literals;

  if ("schema"s == str)
    return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str)
    return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("statistics"s == str)
    return property("statistics", this->_statistics, o.statistics);
  if ("featureTables"s == str)
    return property("featureTables", this->_featureTables, o.featureTables);
  if ("featureTextures"s == str)
    return property(
        "featureTextures",
        this->_featureTextures,
        o.featureTextures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionModelExtFeatureMetadataReader::
    ExtensionModelExtFeatureMetadataReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionModelExtFeatureMetadataReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionModelExtFeatureMetadataReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionModelExtFeatureMetadata>
ExtensionModelExtFeatureMetadataReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionModelExtFeatureMetadataJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionModelExtFeatureMetadata>
ExtensionModelExtFeatureMetadataReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionModelExtFeatureMetadataJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionModelExtFeatureMetadata>>
ExtensionModelExtFeatureMetadataReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionModelExtFeatureMetadata,
      ExtensionModelExtFeatureMetadataJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionMeshPrimitiveExtFeatureMetadata.h>
#include <CesiumGltfReader/ExtensionMeshPrimitiveExtFeatureMetadataReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::
    ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _featureIdAttributes(options),
      _featureIdTextures(options),
      _featureTextures() {}

void ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionMeshPrimitiveExtFeatureMetadata(
      CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata::TypeName,
      str,
      *this->_pObject);
}

void ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::
    readObjectKeyExtensionMeshPrimitiveExtFeatureMetadata(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata& o) {
  using namespace std::string_literals;

  if ("featureIdAttributes"s == str)
    return property(
        "featureIdAttributes",
        this->_featureIdAttributes,
        o.featureIdAttributes);
  if ("featureIdTextures"s == str)
    return property(
        "featureIdTextures",
        this->_featureIdTextures,
        o.featureIdTextures);
  if ("featureTextures"s == str)
    return property(
        "featureTextures",
        this->_featureTextures,
        o.featureTextures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionMeshPrimitiveExtFeatureMetadataReader::
    ExtensionMeshPrimitiveExtFeatureMetadataReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionMeshPrimitiveExtFeatureMetadataReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionMeshPrimitiveExtFeatureMetadataReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata>
ExtensionMeshPrimitiveExtFeatureMetadataReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata>
ExtensionMeshPrimitiveExtFeatureMetadataReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata>>
ExtensionMeshPrimitiveExtFeatureMetadataReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata,
      ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtInstanceFeaturesJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtInstanceFeatures.h>
#include <CesiumGltfReader/ExtensionExtInstanceFeaturesReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtInstanceFeaturesJsonHandler::
    ExtensionExtInstanceFeaturesJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _featureIds(options) {}

void ExtensionExtInstanceFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtInstanceFeatures* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtInstanceFeaturesJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtInstanceFeatures(
      CesiumGltf::ExtensionExtInstanceFeatures::TypeName,
      str,
      *this->_pObject);
}

void ExtensionExtInstanceFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionExtInstanceFeatures())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionExtInstanceFeatures&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionExtInstanceFeaturesJsonHandler::
    readObjectKeyExtensionExtInstanceFeatures(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtInstanceFeatures& o) {
  using namespace std::string_literals;

  if ("featureIds"s == str)
    return property("featureIds", this->_featureIds, o.featureIds);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtInstanceFeaturesReader::ExtensionExtInstanceFeaturesReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtInstanceFeaturesReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtInstanceFeaturesReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtInstanceFeatures>
ExtensionExtInstanceFeaturesReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtInstanceFeaturesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtInstanceFeatures>
ExtensionExtInstanceFeaturesReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtInstanceFeaturesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtInstanceFeatures>>
ExtensionExtInstanceFeaturesReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtInstanceFeatures,
      ExtensionExtInstanceFeaturesJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtMeshFeatures.h>
#include <CesiumGltfReader/ExtensionExtMeshFeaturesReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesJsonHandler::ExtensionExtMeshFeaturesJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _featureIds(options) {}

void ExtensionExtMeshFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeatures* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeatures(
      CesiumGltf::ExtensionExtMeshFeatures::TypeName,
      str,
      *this->_pObject);
}

void ExtensionExtMeshFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionExtMeshFeatures())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionExtMeshFeatures&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesJsonHandler::readObjectKeyExtensionExtMeshFeatures(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ExtensionExtMeshFeatures& o) {
  using namespace std::string_literals;

  if ("featureIds"s == str)
    return property("featureIds", this->_featureIds, o.featureIds);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtMeshFeaturesReader::ExtensionExtMeshFeaturesReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtMeshFeaturesReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtMeshFeaturesReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtMeshFeatures>
ExtensionExtMeshFeaturesReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtMeshFeaturesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtMeshFeatures>
ExtensionExtMeshFeaturesReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtMeshFeaturesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtMeshFeatures>>
ExtensionExtMeshFeaturesReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtMeshFeatures,
      ExtensionExtMeshFeaturesJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshGpuInstancingJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtMeshGpuInstancing.h>
#include <CesiumGltfReader/ExtensionExtMeshGpuInstancingReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshGpuInstancingJsonHandler::
    ExtensionExtMeshGpuInstancingJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options), _attributes() {}

void ExtensionExtMeshGpuInstancingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshGpuInstancing* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshGpuInstancingJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshGpuInstancing(
      CesiumGltf::ExtensionExtMeshGpuInstancing::TypeName,
      str,
      *this->_pObject);
}

void ExtensionExtMeshGpuInstancingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionExtMeshGpuInstancing())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionExtMeshGpuInstancing&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionExtMeshGpuInstancingJsonHandler::
    readObjectKeyExtensionExtMeshGpuInstancing(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshGpuInstancing& o) {
  using namespace std::string_literals;

  if ("attributes"s == str)
    return property("attributes", this->_attributes, o.attributes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtMeshGpuInstancingReader::ExtensionExtMeshGpuInstancingReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtMeshGpuInstancingReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtMeshGpuInstancingReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtMeshGpuInstancing>
ExtensionExtMeshGpuInstancingReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtMeshGpuInstancingJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtMeshGpuInstancing>
ExtensionExtMeshGpuInstancingReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtMeshGpuInstancingJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtMeshGpuInstancing>>
ExtensionExtMeshGpuInstancingReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtMeshGpuInstancing,
      ExtensionExtMeshGpuInstancingJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionBufferExtMeshoptCompressionJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionBufferExtMeshoptCompression.h>
#include <CesiumGltfReader/ExtensionBufferExtMeshoptCompressionReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionBufferExtMeshoptCompressionJsonHandler::
    ExtensionBufferExtMeshoptCompressionJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options), _fallback() {}

void ExtensionBufferExtMeshoptCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionBufferExtMeshoptCompression* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionBufferExtMeshoptCompressionJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionBufferExtMeshoptCompression(
      CesiumGltf::ExtensionBufferExtMeshoptCompression::TypeName,
      str,
      *this->_pObject);
}

void ExtensionBufferExtMeshoptCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            CesiumGltf::ExtensionBufferExtMeshoptCompression())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionBufferExtMeshoptCompression&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionBufferExtMeshoptCompressionJsonHandler::
    readObjectKeyExtensionBufferExtMeshoptCompression(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionBufferExtMeshoptCompression& o) {
  using namespace std::string_literals;

  if ("fallback"s == str)
    return property("fallback", this->_fallback, o.fallback);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionBufferExtMeshoptCompressionReader::
    ExtensionBufferExtMeshoptCompressionReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionBufferExtMeshoptCompressionReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionBufferExtMeshoptCompressionReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionBufferExtMeshoptCompression>
ExtensionBufferExtMeshoptCompressionReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionBufferExtMeshoptCompressionJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionBufferExtMeshoptCompression>
ExtensionBufferExtMeshoptCompressionReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionBufferExtMeshoptCompressionJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionBufferExtMeshoptCompression>>
ExtensionBufferExtMeshoptCompressionReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionBufferExtMeshoptCompression,
      ExtensionBufferExtMeshoptCompressionJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionBufferViewExtMeshoptCompressionJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionBufferViewExtMeshoptCompression.h>
#include <CesiumGltfReader/ExtensionBufferViewExtMeshoptCompressionReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionBufferViewExtMeshoptCompressionJsonHandler::
    ExtensionBufferViewExtMeshoptCompressionJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _byteStride(),
      _count(),
      _mode(),
      _filter() {}

void ExtensionBufferViewExtMeshoptCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionBufferViewExtMeshoptCompression* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionBufferViewExtMeshoptCompressionJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionBufferViewExtMeshoptCompression(
      CesiumGltf::ExtensionBufferViewExtMeshoptCompression::TypeName,
      str,
      *this->_pObject);
}

void ExtensionBufferViewExtMeshoptCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              CesiumGltf::ExtensionBufferViewExtMeshoptCompression())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionBufferViewExtMeshoptCompression&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionBufferViewExtMeshoptCompressionJsonHandler::
    readObjectKeyExtensionBufferViewExtMeshoptCompression(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionBufferViewExtMeshoptCompression& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("byteStride"s == str)
    return property("byteStride", this->_byteStride, o.byteStride);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("mode"s == str)
    return property("mode", this->_mode, o.mode);
  if ("filter"s == str)
    return property("filter", this->_filter, o.filter);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionBufferViewExtMeshoptCompressionReader::
    ExtensionBufferViewExtMeshoptCompressionReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionBufferViewExtMeshoptCompressionReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionBufferViewExtMeshoptCompressionReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionBufferViewExtMeshoptCompression>
ExtensionBufferViewExtMeshoptCompressionReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionBufferViewExtMeshoptCompressionJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionBufferViewExtMeshoptCompression>
ExtensionBufferViewExtMeshoptCompressionReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionBufferViewExtMeshoptCompressionJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionBufferViewExtMeshoptCompression>>
ExtensionBufferViewExtMeshoptCompressionReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionBufferViewExtMeshoptCompression,
      ExtensionBufferViewExtMeshoptCompressionJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionModelExtStructuralMetadataJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionModelExtStructuralMetadata.h>
#include <CesiumGltfReader/ExtensionModelExtStructuralMetadataReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionModelExtStructuralMetadataJsonHandler::
    ExtensionModelExtStructuralMetadataJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _schema(options),
      _schemaUri(),
      _propertyTables(options),
      _propertyTextures(options),
      _propertyAttributes(options) {}

void ExtensionModelExtStructuralMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionModelExtStructuralMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionModelExtStructuralMetadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionModelExtStructuralMetadata(
      CesiumGltf::ExtensionModelExtStructuralMetadata::TypeName,
      str,
      *this->_pObject);
}

void ExtensionModelExtStructuralMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            CesiumGltf::ExtensionModelExtStructuralMetadata())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionModelExtStructuralMetadata&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionModelExtStructuralMetadataJsonHandler::
    readObjectKeyExtensionModelExtStructuralMetadata(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionModelExtStructuralMetadata& o) {
  using namespace std::string_literals;

  if ("schema"s == str)
    return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str)
    return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("propertyTables"s == str)
    return property("propertyTables", this->_propertyTables, o.propertyTables);
  if ("propertyTextures"s == str)
    return property(
        "propertyTextures",
        this->_propertyTextures,
        o.propertyTextures);
  if ("propertyAttributes"s == str)
    return property(
        "propertyAttributes",
        this->_propertyAttributes,
        o.propertyAttributes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionModelExtStructuralMetadataReader::
    ExtensionModelExtStructuralMetadataReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionModelExtStructuralMetadataReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionModelExtStructuralMetadataReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionModelExtStructuralMetadata>
ExtensionModelExtStructuralMetadataReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionModelExtStructuralMetadataJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionModelExtStructuralMetadata>
ExtensionModelExtStructuralMetadataReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionModelExtStructuralMetadataJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionModelExtStructuralMetadata>>
ExtensionModelExtStructuralMetadataReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionModelExtStructuralMetadata,
      ExtensionModelExtStructuralMetadataJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionMeshPrimitiveExtStructuralMetadata.h>
#include <CesiumGltfReader/ExtensionMeshPrimitiveExtStructuralMetadataReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler::
    ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _propertyTextures(),
      _propertyAttributes() {}

void ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionMeshPrimitiveExtStructuralMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionMeshPrimitiveExtStructuralMetadata(
      CesiumGltf::ExtensionMeshPrimitiveExtStructuralMetadata::TypeName,
      str,
      *this->_pObject);
}

void ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              CesiumGltf::ExtensionMeshPrimitiveExtStructuralMetadata())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionMeshPrimitiveExtStructuralMetadata&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler::
    readObjectKeyExtensionMeshPrimitiveExtStructuralMetadata(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionMeshPrimitiveExtStructuralMetadata& o) {
  using namespace std::string_literals;

  if ("propertyTextures"s == str)
    return property(
        "propertyTextures",
        this->_propertyTextures,
        o.propertyTextures);
  if ("propertyAttributes"s == str)
    return property(
        "propertyAttributes",
        this->_propertyAttributes,
        o.propertyAttributes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionMeshPrimitiveExtStructuralMetadataReader::
    ExtensionMeshPrimitiveExtStructuralMetadataReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionMeshPrimitiveExtStructuralMetadataReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionMeshPrimitiveExtStructuralMetadataReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionMeshPrimitiveExtStructuralMetadata>
ExtensionMeshPrimitiveExtStructuralMetadataReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionMeshPrimitiveExtStructuralMetadata>
ExtensionMeshPrimitiveExtStructuralMetadataReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionMeshPrimitiveExtStructuralMetadata>>
ExtensionMeshPrimitiveExtStructuralMetadataReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionMeshPrimitiveExtStructuralMetadata,
      ExtensionMeshPrimitiveExtStructuralMetadataJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionKhrDracoMeshCompressionJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionKhrDracoMeshCompression.h>
#include <CesiumGltfReader/ExtensionKhrDracoMeshCompressionReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionKhrDracoMeshCompressionJsonHandler::
    ExtensionKhrDracoMeshCompressionJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _bufferView(),
      _attributes() {}

void ExtensionKhrDracoMeshCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionKhrDracoMeshCompression* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionKhrDracoMeshCompressionJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionKhrDracoMeshCompression(
      CesiumGltf::ExtensionKhrDracoMeshCompression::TypeName,
      str,
      *this->_pObject);
}

void ExtensionKhrDracoMeshCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            CesiumGltf::ExtensionKhrDracoMeshCompression())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionKhrDracoMeshCompression&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionKhrDracoMeshCompressionJsonHandler::
    readObjectKeyExtensionKhrDracoMeshCompression(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionKhrDracoMeshCompression& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("attributes"s == str)
    return property("attributes", this->_attributes, o.attributes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionKhrDracoMeshCompressionReader::
    ExtensionKhrDracoMeshCompressionReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionKhrDracoMeshCompressionReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionKhrDracoMeshCompressionReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionKhrDracoMeshCompression>
ExtensionKhrDracoMeshCompressionReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionKhrDracoMeshCompressionJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionKhrDracoMeshCompression>
ExtensionKhrDracoMeshCompressionReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionKhrDracoMeshCompressionJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionKhrDracoMeshCompression>>
ExtensionKhrDracoMeshCompressionReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionKhrDracoMeshCompression,
      ExtensionKhrDracoMeshCompressionJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionKhrMaterialsUnlitJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionKhrMaterialsUnlit.h>
#include <CesiumGltfReader/ExtensionKhrMaterialsUnlitReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionKhrMaterialsUnlitJsonHandler::ExtensionKhrMaterialsUnlitJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options) {}

void ExtensionKhrMaterialsUnlitJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionKhrMaterialsUnlit* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionKhrMaterialsUnlitJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionKhrMaterialsUnlit(
      CesiumGltf::ExtensionKhrMaterialsUnlit::TypeName,
      str,
      *this->_pObject);
}

void ExtensionKhrMaterialsUnlitJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionKhrMaterialsUnlit())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionKhrMaterialsUnlit&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionKhrMaterialsUnlitJsonHandler::readObjectKeyExtensionKhrMaterialsUnlit(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ExtensionKhrMaterialsUnlit& o) {
  using namespace std::string_literals;

  (void)o;

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionKhrMaterialsUnlitReader::ExtensionKhrMaterialsUnlitReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionKhrMaterialsUnlitReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionKhrMaterialsUnlitReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionKhrMaterialsUnlit>
ExtensionKhrMaterialsUnlitReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionKhrMaterialsUnlitJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionKhrMaterialsUnlit>
ExtensionKhrMaterialsUnlitReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionKhrMaterialsUnlitJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionKhrMaterialsUnlit>>
ExtensionKhrMaterialsUnlitReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionKhrMaterialsUnlit,
      ExtensionKhrMaterialsUnlitJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionModelKhrMaterialsVariantsJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionModelKhrMaterialsVariants.h>
#include <CesiumGltfReader/ExtensionModelKhrMaterialsVariantsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionModelKhrMaterialsVariantsJsonHandler::
    ExtensionModelKhrMaterialsVariantsJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _variants(options) {}

void ExtensionModelKhrMaterialsVariantsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionModelKhrMaterialsVariants* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionModelKhrMaterialsVariantsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionModelKhrMaterialsVariants(
      CesiumGltf::ExtensionModelKhrMaterialsVariants::TypeName,
      str,
      *this->_pObject);
}

void ExtensionModelKhrMaterialsVariantsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            CesiumGltf::ExtensionModelKhrMaterialsVariants())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionModelKhrMaterialsVariants&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionModelKhrMaterialsVariantsJsonHandler::
    readObjectKeyExtensionModelKhrMaterialsVariants(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionModelKhrMaterialsVariants& o) {
  using namespace std::string_literals;

  if ("variants"s == str)
    return property("variants", this->_variants, o.variants);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionModelKhrMaterialsVariantsReader::
    ExtensionModelKhrMaterialsVariantsReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionModelKhrMaterialsVariantsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionModelKhrMaterialsVariantsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionModelKhrMaterialsVariants>
ExtensionModelKhrMaterialsVariantsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionModelKhrMaterialsVariantsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionModelKhrMaterialsVariants>
ExtensionModelKhrMaterialsVariantsReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionModelKhrMaterialsVariantsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionModelKhrMaterialsVariants>>
ExtensionModelKhrMaterialsVariantsReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionModelKhrMaterialsVariants,
      ExtensionModelKhrMaterialsVariantsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionMeshPrimitiveKhrMaterialsVariants.h>
#include <CesiumGltfReader/ExtensionMeshPrimitiveKhrMaterialsVariantsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler::
    ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _mappings(options) {}

void ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariants* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionMeshPrimitiveKhrMaterialsVariants(
      CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariants::TypeName,
      str,
      *this->_pObject);
}

void ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariants())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariants&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler::
    readObjectKeyExtensionMeshPrimitiveKhrMaterialsVariants(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariants& o) {
  using namespace std::string_literals;

  if ("mappings"s == str)
    return property("mappings", this->_mappings, o.mappings);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionMeshPrimitiveKhrMaterialsVariantsReader::
    ExtensionMeshPrimitiveKhrMaterialsVariantsReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionMeshPrimitiveKhrMaterialsVariantsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionMeshPrimitiveKhrMaterialsVariantsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariants>
ExtensionMeshPrimitiveKhrMaterialsVariantsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariants>
ExtensionMeshPrimitiveKhrMaterialsVariantsReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariants>>
ExtensionMeshPrimitiveKhrMaterialsVariantsReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariants,
      ExtensionMeshPrimitiveKhrMaterialsVariantsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionKhrTextureBasisuJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionKhrTextureBasisu.h>
#include <CesiumGltfReader/ExtensionKhrTextureBasisuReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionKhrTextureBasisuJsonHandler::ExtensionKhrTextureBasisuJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options), _source() {}

void ExtensionKhrTextureBasisuJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionKhrTextureBasisu* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionKhrTextureBasisuJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionKhrTextureBasisu(
      CesiumGltf::ExtensionKhrTextureBasisu::TypeName,
      str,
      *this->_pObject);
}

void ExtensionKhrTextureBasisuJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionKhrTextureBasisu())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionKhrTextureBasisu&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionKhrTextureBasisuJsonHandler::readObjectKeyExtensionKhrTextureBasisu(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ExtensionKhrTextureBasisu& o) {
  using namespace std::string_literals;

  if ("source"s == str)
    return property("source", this->_source, o.source);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionKhrTextureBasisuReader::ExtensionKhrTextureBasisuReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionKhrTextureBasisuReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionKhrTextureBasisuReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionKhrTextureBasisu>
ExtensionKhrTextureBasisuReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionKhrTextureBasisuJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionKhrTextureBasisu>
ExtensionKhrTextureBasisuReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionKhrTextureBasisuJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionKhrTextureBasisu>>
ExtensionKhrTextureBasisuReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionKhrTextureBasisu,
      ExtensionKhrTextureBasisuJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionModelMaxarMeshVariantsJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionModelMaxarMeshVariants.h>
#include <CesiumGltfReader/ExtensionModelMaxarMeshVariantsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionModelMaxarMeshVariantsJsonHandler::
    ExtensionModelMaxarMeshVariantsJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _defaultProperty(),
      _variants(options) {}

void ExtensionModelMaxarMeshVariantsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionModelMaxarMeshVariants* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionModelMaxarMeshVariantsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionModelMaxarMeshVariants(
      CesiumGltf::ExtensionModelMaxarMeshVariants::TypeName,
      str,
      *this->_pObject);
}

void ExtensionModelMaxarMeshVariantsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionModelMaxarMeshVariants())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionModelMaxarMeshVariants&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionModelMaxarMeshVariantsJsonHandler::
    readObjectKeyExtensionModelMaxarMeshVariants(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionModelMaxarMeshVariants& o) {
  using namespace std::string_literals;

  if ("default"s == str)
    return property("default", this->_defaultProperty, o.defaultProperty);
  if ("variants"s == str)
    return property("variants", this->_variants, o.variants);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionModelMaxarMeshVariantsReader::ExtensionModelMaxarMeshVariantsReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionModelMaxarMeshVariantsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionModelMaxarMeshVariantsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionModelMaxarMeshVariants>
ExtensionModelMaxarMeshVariantsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionModelMaxarMeshVariantsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionModelMaxarMeshVariants>
ExtensionModelMaxarMeshVariantsReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionModelMaxarMeshVariantsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionModelMaxarMeshVariants>>
ExtensionModelMaxarMeshVariantsReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionModelMaxarMeshVariants,
      ExtensionModelMaxarMeshVariantsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionNodeMaxarMeshVariantsJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionNodeMaxarMeshVariants.h>
#include <CesiumGltfReader/ExtensionNodeMaxarMeshVariantsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionNodeMaxarMeshVariantsJsonHandler::
    ExtensionNodeMaxarMeshVariantsJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _mappings(options) {}

void ExtensionNodeMaxarMeshVariantsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionNodeMaxarMeshVariants* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionNodeMaxarMeshVariantsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionNodeMaxarMeshVariants(
      CesiumGltf::ExtensionNodeMaxarMeshVariants::TypeName,
      str,
      *this->_pObject);
}

void ExtensionNodeMaxarMeshVariantsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionNodeMaxarMeshVariants())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionNodeMaxarMeshVariants&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionNodeMaxarMeshVariantsJsonHandler::
    readObjectKeyExtensionNodeMaxarMeshVariants(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionNodeMaxarMeshVariants& o) {
  using namespace std::string_literals;

  if ("mappings"s == str)
    return property("mappings", this->_mappings, o.mappings);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionNodeMaxarMeshVariantsReader::ExtensionNodeMaxarMeshVariantsReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionNodeMaxarMeshVariantsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionNodeMaxarMeshVariantsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionNodeMaxarMeshVariants>
ExtensionNodeMaxarMeshVariantsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionNodeMaxarMeshVariantsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionNodeMaxarMeshVariants>
ExtensionNodeMaxarMeshVariantsReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionNodeMaxarMeshVariantsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionNodeMaxarMeshVariants>>
ExtensionNodeMaxarMeshVariantsReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionNodeMaxarMeshVariants,
      ExtensionNodeMaxarMeshVariantsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionKhrTextureTransformJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionKhrTextureTransform.h>
#include <CesiumGltfReader/ExtensionKhrTextureTransformReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionKhrTextureTransformJsonHandler::
    ExtensionKhrTextureTransformJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _offset(),
      _rotation(),
      _scale(),
      _texCoord() {}

void ExtensionKhrTextureTransformJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionKhrTextureTransform* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionKhrTextureTransformJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionKhrTextureTransform(
      CesiumGltf::ExtensionKhrTextureTransform::TypeName,
      str,
      *this->_pObject);
}

void ExtensionKhrTextureTransformJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionKhrTextureTransform())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionKhrTextureTransform&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionKhrTextureTransformJsonHandler::
    readObjectKeyExtensionKhrTextureTransform(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionKhrTextureTransform& o) {
  using namespace std::string_literals;

  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("rotation"s == str)
    return property("rotation", this->_rotation, o.rotation);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("texCoord"s == str)
    return property("texCoord", this->_texCoord, o.texCoord);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionKhrTextureTransformReader::ExtensionKhrTextureTransformReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionKhrTextureTransformReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionKhrTextureTransformReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionKhrTextureTransform>
ExtensionKhrTextureTransformReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionKhrTextureTransformJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionKhrTextureTransform>
ExtensionKhrTextureTransformReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionKhrTextureTransformJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionKhrTextureTransform>>
ExtensionKhrTextureTransformReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionKhrTextureTransform,
      ExtensionKhrTextureTransformJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionTextureWebpJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionTextureWebp.h>
#include <CesiumGltfReader/ExtensionTextureWebpReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionTextureWebpJsonHandler::ExtensionTextureWebpJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options), _source() {}

void ExtensionTextureWebpJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionTextureWebp* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionTextureWebpJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionTextureWebp(
      CesiumGltf::ExtensionTextureWebp::TypeName,
      str,
      *this->_pObject);
}

void ExtensionTextureWebpJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions.emplace(extensionName, CesiumGltf::ExtensionTextureWebp())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionTextureWebp&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionTextureWebpJsonHandler::readObjectKeyExtensionTextureWebp(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ExtensionTextureWebp& o) {
  using namespace std::string_literals;

  if ("source"s == str)
    return property("source", this->_source, o.source);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionTextureWebpReader::ExtensionTextureWebpReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& ExtensionTextureWebpReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionTextureWebpReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionTextureWebp>
ExtensionTextureWebpReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionTextureWebpJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionTextureWebp>
ExtensionTextureWebpReader::readFromJson(const rapidjson::Value& value) const {
  ExtensionTextureWebpJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::ExtensionTextureWebp>>
ExtensionTextureWebpReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionTextureWebp,
      ExtensionTextureWebpJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionNodeMaxarMeshVariantsMappingsValueJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionNodeMaxarMeshVariantsMappingsValue.h>
#include <CesiumGltfReader/ExtensionNodeMaxarMeshVariantsMappingsValueReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionNodeMaxarMeshVariantsMappingsValueJsonHandler::
    ExtensionNodeMaxarMeshVariantsMappingsValueJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _variants(),
      _mesh(),
      _name() {}

void ExtensionNodeMaxarMeshVariantsMappingsValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionNodeMaxarMeshVariantsMappingsValue* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionNodeMaxarMeshVariantsMappingsValueJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionNodeMaxarMeshVariantsMappingsValue(
      CesiumGltf::ExtensionNodeMaxarMeshVariantsMappingsValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionNodeMaxarMeshVariantsMappingsValueJsonHandler::
    readObjectKeyExtensionNodeMaxarMeshVariantsMappingsValue(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionNodeMaxarMeshVariantsMappingsValue& o) {
  using namespace std::string_literals;

  if ("variants"s == str)
    return property("variants", this->_variants, o.variants);
  if ("mesh"s == str)
    return property("mesh", this->_mesh, o.mesh);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionNodeMaxarMeshVariantsMappingsValueReader::
    ExtensionNodeMaxarMeshVariantsMappingsValueReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionNodeMaxarMeshVariantsMappingsValueReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionNodeMaxarMeshVariantsMappingsValueReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionNodeMaxarMeshVariantsMappingsValue>
ExtensionNodeMaxarMeshVariantsMappingsValueReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionNodeMaxarMeshVariantsMappingsValueJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionNodeMaxarMeshVariantsMappingsValue>
ExtensionNodeMaxarMeshVariantsMappingsValueReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionNodeMaxarMeshVariantsMappingsValueJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionNodeMaxarMeshVariantsMappingsValue>>
ExtensionNodeMaxarMeshVariantsMappingsValueReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionNodeMaxarMeshVariantsMappingsValue,
      ExtensionNodeMaxarMeshVariantsMappingsValueJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionModelMaxarMeshVariantsValueJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionModelMaxarMeshVariantsValue.h>
#include <CesiumGltfReader/ExtensionModelMaxarMeshVariantsValueReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionModelMaxarMeshVariantsValueJsonHandler::
    ExtensionModelMaxarMeshVariantsValueJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options), _name() {}

void ExtensionModelMaxarMeshVariantsValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionModelMaxarMeshVariantsValue* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionModelMaxarMeshVariantsValueJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionModelMaxarMeshVariantsValue(
      CesiumGltf::ExtensionModelMaxarMeshVariantsValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionModelMaxarMeshVariantsValueJsonHandler::
    readObjectKeyExtensionModelMaxarMeshVariantsValue(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionModelMaxarMeshVariantsValue& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

ExtensionModelMaxarMeshVariantsValueReader::
    ExtensionModelMaxarMeshVariantsValueReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionModelMaxarMeshVariantsValueReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionModelMaxarMeshVariantsValueReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionModelMaxarMeshVariantsValue>
ExtensionModelMaxarMeshVariantsValueReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionModelMaxarMeshVariantsValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionModelMaxarMeshVariantsValue>
ExtensionModelMaxarMeshVariantsValueReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionModelMaxarMeshVariantsValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionModelMaxarMeshVariantsValue>>
ExtensionModelMaxarMeshVariantsValueReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionModelMaxarMeshVariantsValue,
      ExtensionModelMaxarMeshVariantsValueJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue.h>
#include <CesiumGltfReader/ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueJsonHandler::
    ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _variants(),
      _material(),
      _name() {}

void ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue*
        pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueJsonHandler::
    readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this
      ->readObjectKeyExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue(
          CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue::
              TypeName,
          str,
          *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueJsonHandler::
    readObjectKeyExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue&
            o) {
  using namespace std::string_literals;

  if ("variants"s == str)
    return property("variants", this->_variants, o.variants);
  if ("material"s == str)
    return property("material", this->_material, o.material);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueReader::
    ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueReader::getOptions()
    const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue>
ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue>
ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<
    CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue>>
ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueReader::
    readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValue,
      ExtensionMeshPrimitiveKhrMaterialsVariantsMappingsValueJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionModelKhrMaterialsVariantsValueJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionModelKhrMaterialsVariantsValue.h>
#include <CesiumGltfReader/ExtensionModelKhrMaterialsVariantsValueReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionModelKhrMaterialsVariantsValueJsonHandler::
    ExtensionModelKhrMaterialsVariantsValueJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options), _name() {}

void ExtensionModelKhrMaterialsVariantsValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionModelKhrMaterialsVariantsValue* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionModelKhrMaterialsVariantsValueJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionModelKhrMaterialsVariantsValue(
      CesiumGltf::ExtensionModelKhrMaterialsVariantsValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionModelKhrMaterialsVariantsValueJsonHandler::
    readObjectKeyExtensionModelKhrMaterialsVariantsValue(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionModelKhrMaterialsVariantsValue& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

ExtensionModelKhrMaterialsVariantsValueReader::
    ExtensionModelKhrMaterialsVariantsValueReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionModelKhrMaterialsVariantsValueReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionModelKhrMaterialsVariantsValueReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionModelKhrMaterialsVariantsValue>
ExtensionModelKhrMaterialsVariantsValueReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionModelKhrMaterialsVariantsValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionModelKhrMaterialsVariantsValue>
ExtensionModelKhrMaterialsVariantsValueReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionModelKhrMaterialsVariantsValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionModelKhrMaterialsVariantsValue>>
ExtensionModelKhrMaterialsVariantsValueReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionModelKhrMaterialsVariantsValue,
      ExtensionModelKhrMaterialsVariantsValueJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyAttributeJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/PropertyAttribute.h>
#include <CesiumGltfReader/PropertyAttributeReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

PropertyAttributeJsonHandler::PropertyAttributeJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _classProperty(),
      _properties(options) {}

void PropertyAttributeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::PropertyAttribute* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyAttributeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyAttribute(
      CesiumGltf::PropertyAttribute::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyAttributeJsonHandler::readObjectKeyPropertyAttribute(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::PropertyAttribute& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

PropertyAttributeReader::PropertyAttributeReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& PropertyAttributeReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertyAttributeReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyAttribute>
PropertyAttributeReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  PropertyAttributeJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyAttribute>
PropertyAttributeReader::readFromJson(const rapidjson::Value& value) const {
  PropertyAttributeJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::PropertyAttribute>>
PropertyAttributeReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::PropertyAttribute,
      PropertyAttributeJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyAttributePropertyJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/PropertyAttributeProperty.h>
#include <CesiumGltfReader/PropertyAttributePropertyReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

PropertyAttributePropertyJsonHandler::PropertyAttributePropertyJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _attribute(),
      _offset(),
      _scale(),
      _max(),
      _min() {}

void PropertyAttributePropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::PropertyAttributeProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyAttributePropertyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyAttributeProperty(
      CesiumGltf::PropertyAttributeProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyAttributePropertyJsonHandler::readObjectKeyPropertyAttributeProperty(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::PropertyAttributeProperty& o) {
  using namespace std::string_literals;

  if ("attribute"s == str)
    return property("attribute", this->_attribute, o.attribute);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

PropertyAttributePropertyReader::PropertyAttributePropertyReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
PropertyAttributePropertyReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertyAttributePropertyReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyAttributeProperty>
PropertyAttributePropertyReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  PropertyAttributePropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyAttributeProperty>
PropertyAttributePropertyReader::readFromJson(
    const rapidjson::Value& value) const {
  PropertyAttributePropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::PropertyAttributeProperty>>
PropertyAttributePropertyReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::PropertyAttributeProperty,
      PropertyAttributePropertyJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTextureJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/PropertyTexture.h>
#include <CesiumGltfReader/PropertyTextureReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

PropertyTextureJsonHandler::PropertyTextureJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _classProperty(),
      _properties(options) {}

void PropertyTextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::PropertyTexture* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyTexture(
      CesiumGltf::PropertyTexture::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTextureJsonHandler::readObjectKeyPropertyTexture(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::PropertyTexture& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

PropertyTextureReader::PropertyTextureReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& PropertyTextureReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertyTextureReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyTexture>
PropertyTextureReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  PropertyTextureJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyTexture>
PropertyTextureReader::readFromJson(const rapidjson::Value& value) const {
  PropertyTextureJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::PropertyTexture>>
PropertyTextureReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::PropertyTexture, PropertyTextureJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTexturePropertyJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/PropertyTextureProperty.h>
#include <CesiumGltfReader/PropertyTexturePropertyReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

PropertyTexturePropertyJsonHandler::PropertyTexturePropertyJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : TextureInfoJsonHandler(options),
      _channels(),
      _offset(),
      _scale(),
      _max(),
      _min() {}

void PropertyTexturePropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::PropertyTextureProperty* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTexturePropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyTextureProperty(
      CesiumGltf::PropertyTextureProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTexturePropertyJsonHandler::readObjectKeyPropertyTextureProperty(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::PropertyTextureProperty& o) {
  using namespace std::string_literals;

  if ("channels"s == str)
    return property("channels", this->_channels, o.channels);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}

PropertyTexturePropertyReader::PropertyTexturePropertyReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
PropertyTexturePropertyReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertyTexturePropertyReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyTextureProperty>
PropertyTexturePropertyReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  PropertyTexturePropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyTextureProperty>
PropertyTexturePropertyReader::readFromJson(
    const rapidjson::Value& value) const {
  PropertyTexturePropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::PropertyTextureProperty>>
PropertyTexturePropertyReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::PropertyTextureProperty,
      PropertyTexturePropertyJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TextureInfoJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/TextureInfo.h>
#include <CesiumGltfReader/TextureInfoReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

TextureInfoJsonHandler::TextureInfoJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _index(),
      _texCoord() {}

void TextureInfoJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::TextureInfo* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TextureInfoJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTextureInfo(
      CesiumGltf::TextureInfo::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
TextureInfoJsonHandler::readObjectKeyTextureInfo(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::TextureInfo& o) {
  using namespace std::string_literals;

  if ("index"s == str)
    return property("index", this->_index, o.index);
  if ("texCoord"s == str)
    return property("texCoord", this->_texCoord, o.texCoord);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

TextureInfoReader::TextureInfoReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& TextureInfoReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
TextureInfoReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::TextureInfo>
TextureInfoReader::readFromJson(const gsl::span<const std::byte>& data) const {
  TextureInfoJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::TextureInfo>
TextureInfoReader::readFromJson(const rapidjson::Value& value) const {
  TextureInfoJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::TextureInfo>>
TextureInfoReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::TextureInfo, TextureInfoJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTableJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/PropertyTable.h>
#include <CesiumGltfReader/PropertyTableReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

PropertyTableJsonHandler::PropertyTableJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _classProperty(),
      _count(),
      _properties(options) {}

void PropertyTableJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::PropertyTable* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTableJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyTable(
      CesiumGltf::PropertyTable::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTableJsonHandler::readObjectKeyPropertyTable(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::PropertyTable& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

PropertyTableReader::PropertyTableReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& PropertyTableReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertyTableReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyTable>
PropertyTableReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  PropertyTableJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyTable>
PropertyTableReader::readFromJson(const rapidjson::Value& value) const {
  PropertyTableJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::PropertyTable>>
PropertyTableReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::PropertyTable, PropertyTableJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTablePropertyJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/PropertyTableProperty.h>
#include <CesiumGltfReader/PropertyTablePropertyReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

PropertyTablePropertyJsonHandler::PropertyTablePropertyJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _values(),
      _arrayOffsets(),
      _stringOffsets(),
      _arrayOffsetType(),
      _stringOffsetType(),
      _offset(),
      _scale(),
      _max(),
      _min() {}

void PropertyTablePropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::PropertyTableProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTablePropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyTableProperty(
      CesiumGltf::PropertyTableProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTablePropertyJsonHandler::readObjectKeyPropertyTableProperty(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::PropertyTableProperty& o) {
  using namespace std::string_literals;

  if ("values"s == str)
    return property("values", this->_values, o.values);
  if ("arrayOffsets"s == str)
    return property("arrayOffsets", this->_arrayOffsets, o.arrayOffsets);
  if ("stringOffsets"s == str)
    return property("stringOffsets", this->_stringOffsets, o.stringOffsets);
  if ("arrayOffsetType"s == str)
    return property(
        "arrayOffsetType",
        this->_arrayOffsetType,
        o.arrayOffsetType);
  if ("stringOffsetType"s == str)
    return property(
        "stringOffsetType",
        this->_stringOffsetType,
        o.stringOffsetType);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

PropertyTablePropertyReader::PropertyTablePropertyReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& PropertyTablePropertyReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertyTablePropertyReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyTableProperty>
PropertyTablePropertyReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  PropertyTablePropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::PropertyTableProperty>
PropertyTablePropertyReader::readFromJson(const rapidjson::Value& value) const {
  PropertyTablePropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::PropertyTableProperty>>
PropertyTablePropertyReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::PropertyTableProperty,
      PropertyTablePropertyJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SchemaJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Schema.h>
#include <CesiumGltfReader/SchemaReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

SchemaJsonHandler::SchemaJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _id(),
      _name(),
      _description(),
      _version(),
      _classes(options),
      _enums(options) {}

void SchemaJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Schema* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SchemaJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySchema(
      CesiumGltf::Schema::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SchemaJsonHandler::readObjectKeySchema(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Schema& o) {
  using namespace std::string_literals;

  if ("id"s == str)
    return property("id", this->_id, o.id);
  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);
  if ("enums"s == str)
    return property("enums", this->_enums, o.enums);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

SchemaReader::SchemaReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& SchemaReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& SchemaReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Schema>
SchemaReader::readFromJson(const gsl::span<const std::byte>& data) const {
  SchemaJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Schema>
SchemaReader::readFromJson(const rapidjson::Value& value) const {
  SchemaJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Schema>>
SchemaReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Schema, SchemaJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Enum.h>
#include <CesiumGltfReader/EnumReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

EnumJsonHandler::EnumJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _valueType(),
      _values(options) {}

void EnumJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Enum* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnum(
      CesiumGltf::Enum::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumJsonHandler::readObjectKeyEnum(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Enum& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("valueType"s == str)
    return property("valueType", this->_valueType, o.valueType);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

EnumReader::EnumReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& EnumReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& EnumReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Enum>
EnumReader::readFromJson(const gsl::span<const std::byte>& data) const {
  EnumJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Enum>
EnumReader::readFromJson(const rapidjson::Value& value) const {
  EnumJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Enum>>
EnumReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Enum, EnumJsonHandler> handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumValueJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/EnumValue.h>
#include <CesiumGltfReader/EnumValueReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

EnumValueJsonHandler::EnumValueJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _value() {}

void EnumValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::EnumValue* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumValueJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnumValue(
      CesiumGltf::EnumValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumValueJsonHandler::readObjectKeyEnumValue(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::EnumValue& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("value"s == str)
    return property("value", this->_value, o.value);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

EnumValueReader::EnumValueReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& EnumValueReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& EnumValueReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::EnumValue>
EnumValueReader::readFromJson(const gsl::span<const std::byte>& data) const {
  EnumValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::EnumValue>
EnumValueReader::readFromJson(const rapidjson::Value& value) const {
  EnumValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::EnumValue>>
EnumValueReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::EnumValue, EnumValueJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Class.h>
#include <CesiumGltfReader/ClassReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ClassJsonHandler::ClassJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _properties(options) {}

void ClassJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Class* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClass(
      CesiumGltf::Class::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ClassJsonHandler::readObjectKeyClass(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Class& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ClassReader::ClassReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& ClassReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& ClassReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Class>
ClassReader::readFromJson(const gsl::span<const std::byte>& data) const {
  ClassJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Class>
ClassReader::readFromJson(const rapidjson::Value& value) const {
  ClassJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Class>>
ClassReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Class, ClassJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassPropertyJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ClassProperty.h>
#include <CesiumGltfReader/ClassPropertyReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ClassPropertyJsonHandler::ClassPropertyJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _type(),
      _componentType(),
      _enumType(),
      _array(),
      _count(),
      _normalized(),
      _offset(),
      _scale(),
      _max(),
      _min(),
      _required(),
      _noData(),
      _defaultProperty(),
      _semantic() {}

void ClassPropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ClassProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClassProperty(
      CesiumGltf::ClassProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKeyClassProperty(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ClassProperty& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("enumType"s == str)
    return property("enumType", this->_enumType, o.enumType);
  if ("array"s == str)
    return property("array", this->_array, o.array);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("required"s == str)
    return property("required", this->_required, o.required);
  if ("noData"s == str)
    return property("noData", this->_noData, o.noData);
  if ("default"s == str)
    return property("default", this->_defaultProperty, o.defaultProperty);
  if ("semantic"s == str)
    return property("semantic", this->_semantic, o.semantic);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ClassPropertyReader::ClassPropertyReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& ClassPropertyReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ClassPropertyReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ClassProperty>
ClassPropertyReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ClassPropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ClassProperty>
ClassPropertyReader::readFromJson(const rapidjson::Value& value) const {
  ClassPropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::ClassProperty>>
ClassPropertyReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::ClassProperty, ClassPropertyJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureIdJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/FeatureId.h>
#include <CesiumGltfReader/FeatureIdReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

FeatureIdJsonHandler::FeatureIdJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _featureCount(),
      _nullFeatureId(),
      _label(),
      _attribute(),
      _texture(options),
      _propertyTable() {}

void FeatureIdJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::FeatureId* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
FeatureIdJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureId(
      CesiumGltf::FeatureId::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* FeatureIdJsonHandler::readObjectKeyFeatureId(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::FeatureId& o) {
  using namespace std::string_literals;

  if ("featureCount"s == str)
    return property("featureCount", this->_featureCount, o.featureCount);
  if ("nullFeatureId"s == str)
    return property("nullFeatureId", this->_nullFeatureId, o.nullFeatureId);
  if ("label"s == str)
    return property("label", this->_label, o.label);
  if ("attribute"s == str)
    return property("attribute", this->_attribute, o.attribute);
  if ("texture"s == str)
    return property("texture", this->_texture, o.texture);
  if ("propertyTable"s == str)
    return property("propertyTable", this->_propertyTable, o.propertyTable);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

FeatureIdReader::FeatureIdReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& FeatureIdReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& FeatureIdReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::FeatureId>
FeatureIdReader::readFromJson(const gsl::span<const std::byte>& data) const {
  FeatureIdJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::FeatureId>
FeatureIdReader::readFromJson(const rapidjson::Value& value) const {
  FeatureIdJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::FeatureId>>
FeatureIdReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::FeatureId, FeatureIdJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureIdTextureJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/FeatureIdTexture.h>
#include <CesiumGltfReader/FeatureIdTextureReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

FeatureIdTextureJsonHandler::FeatureIdTextureJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : TextureInfoJsonHandler(options), _channels() {}

void FeatureIdTextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::FeatureIdTexture* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
FeatureIdTextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureIdTexture(
      CesiumGltf::FeatureIdTexture::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
FeatureIdTextureJsonHandler::readObjectKeyFeatureIdTexture(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::FeatureIdTexture& o) {
  using namespace std::string_literals;

  if ("channels"s == str)
    return property("channels", this->_channels, o.channels);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}

FeatureIdTextureReader::FeatureIdTextureReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& FeatureIdTextureReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
FeatureIdTextureReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::FeatureIdTexture>
FeatureIdTextureReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  FeatureIdTextureJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::FeatureIdTexture>
FeatureIdTextureReader::readFromJson(const rapidjson::Value& value) const {
  FeatureIdTextureJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::FeatureIdTexture>>
FeatureIdTextureReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::FeatureIdTexture,
      FeatureIdTextureJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtInstanceFeaturesFeatureIdJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtInstanceFeaturesFeatureId.h>
#include <CesiumGltfReader/ExtensionExtInstanceFeaturesFeatureIdReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtInstanceFeaturesFeatureIdJsonHandler::
    ExtensionExtInstanceFeaturesFeatureIdJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _featureCount(),
      _nullFeatureId(),
      _label(),
      _attribute(),
      _propertyTable() {}

void ExtensionExtInstanceFeaturesFeatureIdJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtInstanceFeaturesFeatureId* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtInstanceFeaturesFeatureIdJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtInstanceFeaturesFeatureId(
      CesiumGltf::ExtensionExtInstanceFeaturesFeatureId::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtInstanceFeaturesFeatureIdJsonHandler::
    readObjectKeyExtensionExtInstanceFeaturesFeatureId(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtInstanceFeaturesFeatureId& o) {
  using namespace std::string_literals;

  if ("featureCount"s == str)
    return property("featureCount", this->_featureCount, o.featureCount);
  if ("nullFeatureId"s == str)
    return property("nullFeatureId", this->_nullFeatureId, o.nullFeatureId);
  if ("label"s == str)
    return property("label", this->_label, o.label);
  if ("attribute"s == str)
    return property("attribute", this->_attribute, o.attribute);
  if ("propertyTable"s == str)
    return property("propertyTable", this->_propertyTable, o.propertyTable);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtInstanceFeaturesFeatureIdReader::
    ExtensionExtInstanceFeaturesFeatureIdReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtInstanceFeaturesFeatureIdReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtInstanceFeaturesFeatureIdReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtInstanceFeaturesFeatureId>
ExtensionExtInstanceFeaturesFeatureIdReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtInstanceFeaturesFeatureIdJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtInstanceFeaturesFeatureId>
ExtensionExtInstanceFeaturesFeatureIdReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtInstanceFeaturesFeatureIdJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtInstanceFeaturesFeatureId>>
ExtensionExtInstanceFeaturesFeatureIdReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtInstanceFeaturesFeatureId,
      ExtensionExtInstanceFeaturesFeatureIdJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataFeatureIDTextureJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataFeatureIDTexture.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataFeatureIDTextureReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataFeatureIDTextureJsonHandler::
    ExtensionExtFeatureMetadataFeatureIDTextureJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _featureTable(),
      _featureIds(options) {}

void ExtensionExtFeatureMetadataFeatureIDTextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataFeatureIDTexture* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureIDTextureJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataFeatureIDTexture(
      CesiumGltf::ExtensionExtFeatureMetadataFeatureIDTexture::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureIDTextureJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataFeatureIDTexture(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataFeatureIDTexture& o) {
  using namespace std::string_literals;

  if ("featureTable"s == str)
    return property("featureTable", this->_featureTable, o.featureTable);
  if ("featureIds"s == str)
    return property("featureIds", this->_featureIds, o.featureIds);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataFeatureIDTextureReader::
    ExtensionExtFeatureMetadataFeatureIDTextureReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureIDTextureReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureIDTextureReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureIDTexture>
ExtensionExtFeatureMetadataFeatureIDTextureReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataFeatureIDTextureJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureIDTexture>
ExtensionExtFeatureMetadataFeatureIDTextureReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataFeatureIDTextureJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataFeatureIDTexture>>
ExtensionExtFeatureMetadataFeatureIDTextureReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataFeatureIDTexture,
      ExtensionExtFeatureMetadataFeatureIDTextureJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataTextureAccessorJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataTextureAccessor.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataTextureAccessorReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataTextureAccessorJsonHandler::
    ExtensionExtFeatureMetadataTextureAccessorJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _channels(),
      _texture(options) {}

void ExtensionExtFeatureMetadataTextureAccessorJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataTextureAccessor* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataTextureAccessorJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataTextureAccessor(
      CesiumGltf::ExtensionExtFeatureMetadataTextureAccessor::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataTextureAccessorJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataTextureAccessor(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataTextureAccessor& o) {
  using namespace std::string_literals;

  if ("channels"s == str)
    return property("channels", this->_channels, o.channels);
  if ("texture"s == str)
    return property("texture", this->_texture, o.texture);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataTextureAccessorReader::
    ExtensionExtFeatureMetadataTextureAccessorReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataTextureAccessorReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataTextureAccessorReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataTextureAccessor>
ExtensionExtFeatureMetadataTextureAccessorReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataTextureAccessorJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataTextureAccessor>
ExtensionExtFeatureMetadataTextureAccessorReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataTextureAccessorJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataTextureAccessor>>
ExtensionExtFeatureMetadataTextureAccessorReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataTextureAccessor,
      ExtensionExtFeatureMetadataTextureAccessorJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataFeatureIDAttributeJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataFeatureIDAttribute.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataFeatureIDAttributeReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataFeatureIDAttributeJsonHandler::
    ExtensionExtFeatureMetadataFeatureIDAttributeJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _featureTable(),
      _featureIds(options) {}

void ExtensionExtFeatureMetadataFeatureIDAttributeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataFeatureIDAttribute* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureIDAttributeJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataFeatureIDAttribute(
      CesiumGltf::ExtensionExtFeatureMetadataFeatureIDAttribute::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureIDAttributeJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataFeatureIDAttribute(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataFeatureIDAttribute& o) {
  using namespace std::string_literals;

  if ("featureTable"s == str)
    return property("featureTable", this->_featureTable, o.featureTable);
  if ("featureIds"s == str)
    return property("featureIds", this->_featureIds, o.featureIds);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataFeatureIDAttributeReader::
    ExtensionExtFeatureMetadataFeatureIDAttributeReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureIDAttributeReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureIDAttributeReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureIDAttribute>
ExtensionExtFeatureMetadataFeatureIDAttributeReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataFeatureIDAttributeJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureIDAttribute>
ExtensionExtFeatureMetadataFeatureIDAttributeReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataFeatureIDAttributeJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataFeatureIDAttribute>>
ExtensionExtFeatureMetadataFeatureIDAttributeReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataFeatureIDAttribute,
      ExtensionExtFeatureMetadataFeatureIDAttributeJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataFeatureIDsJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataFeatureIDs.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataFeatureIDsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataFeatureIDsJsonHandler::
    ExtensionExtFeatureMetadataFeatureIDsJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _attribute(),
      _constant(),
      _divisor() {}

void ExtensionExtFeatureMetadataFeatureIDsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataFeatureIDs* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureIDsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataFeatureIDs(
      CesiumGltf::ExtensionExtFeatureMetadataFeatureIDs::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureIDsJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataFeatureIDs(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataFeatureIDs& o) {
  using namespace std::string_literals;

  if ("attribute"s == str)
    return property("attribute", this->_attribute, o.attribute);
  if ("constant"s == str)
    return property("constant", this->_constant, o.constant);
  if ("divisor"s == str)
    return property("divisor", this->_divisor, o.divisor);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataFeatureIDsReader::
    ExtensionExtFeatureMetadataFeatureIDsReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureIDsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureIDsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureIDs>
ExtensionExtFeatureMetadataFeatureIDsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataFeatureIDsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureIDs>
ExtensionExtFeatureMetadataFeatureIDsReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataFeatureIDsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataFeatureIDs>>
ExtensionExtFeatureMetadataFeatureIDsReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataFeatureIDs,
      ExtensionExtFeatureMetadataFeatureIDsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataFeatureTextureJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataFeatureTexture.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataFeatureTextureReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataFeatureTextureJsonHandler::
    ExtensionExtFeatureMetadataFeatureTextureJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _classProperty(),
      _properties(options) {}

void ExtensionExtFeatureMetadataFeatureTextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataFeatureTexture* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureTextureJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataFeatureTexture(
      CesiumGltf::ExtensionExtFeatureMetadataFeatureTexture::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureTextureJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataFeatureTexture(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataFeatureTexture& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataFeatureTextureReader::
    ExtensionExtFeatureMetadataFeatureTextureReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureTextureReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureTextureReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureTexture>
ExtensionExtFeatureMetadataFeatureTextureReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataFeatureTextureJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureTexture>
ExtensionExtFeatureMetadataFeatureTextureReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataFeatureTextureJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataFeatureTexture>>
ExtensionExtFeatureMetadataFeatureTextureReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataFeatureTexture,
      ExtensionExtFeatureMetadataFeatureTextureJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataFeatureTableJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataFeatureTable.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataFeatureTableReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataFeatureTableJsonHandler::
    ExtensionExtFeatureMetadataFeatureTableJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _classProperty(),
      _count(),
      _properties(options) {}

void ExtensionExtFeatureMetadataFeatureTableJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataFeatureTable* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureTableJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataFeatureTable(
      CesiumGltf::ExtensionExtFeatureMetadataFeatureTable::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureTableJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataFeatureTable(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataFeatureTable& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataFeatureTableReader::
    ExtensionExtFeatureMetadataFeatureTableReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureTableReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureTableReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureTable>
ExtensionExtFeatureMetadataFeatureTableReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataFeatureTableJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureTable>
ExtensionExtFeatureMetadataFeatureTableReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataFeatureTableJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataFeatureTable>>
ExtensionExtFeatureMetadataFeatureTableReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataFeatureTable,
      ExtensionExtFeatureMetadataFeatureTableJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataFeatureTablePropertyJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataFeatureTableProperty.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataFeatureTablePropertyReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataFeatureTablePropertyJsonHandler::
    ExtensionExtFeatureMetadataFeatureTablePropertyJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _bufferView(),
      _offsetType(),
      _arrayOffsetBufferView(),
      _stringOffsetBufferView() {}

void ExtensionExtFeatureMetadataFeatureTablePropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataFeatureTableProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureTablePropertyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataFeatureTableProperty(
      CesiumGltf::ExtensionExtFeatureMetadataFeatureTableProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataFeatureTablePropertyJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataFeatureTableProperty(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataFeatureTableProperty& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("offsetType"s == str)
    return property("offsetType", this->_offsetType, o.offsetType);
  if ("arrayOffsetBufferView"s == str)
    return property(
        "arrayOffsetBufferView",
        this->_arrayOffsetBufferView,
        o.arrayOffsetBufferView);
  if ("stringOffsetBufferView"s == str)
    return property(
        "stringOffsetBufferView",
        this->_stringOffsetBufferView,
        o.stringOffsetBufferView);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataFeatureTablePropertyReader::
    ExtensionExtFeatureMetadataFeatureTablePropertyReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureTablePropertyReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataFeatureTablePropertyReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureTableProperty>
ExtensionExtFeatureMetadataFeatureTablePropertyReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataFeatureTablePropertyJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataFeatureTableProperty>
ExtensionExtFeatureMetadataFeatureTablePropertyReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataFeatureTablePropertyJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataFeatureTableProperty>>
ExtensionExtFeatureMetadataFeatureTablePropertyReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataFeatureTableProperty,
      ExtensionExtFeatureMetadataFeatureTablePropertyJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataStatisticsJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataStatistics.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataStatisticsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataStatisticsJsonHandler::
    ExtensionExtFeatureMetadataStatisticsJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _classes(options) {}

void ExtensionExtFeatureMetadataStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataStatisticsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataStatistics(
      CesiumGltf::ExtensionExtFeatureMetadataStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataStatisticsJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataStatistics(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataStatistics& o) {
  using namespace std::string_literals;

  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataStatisticsReader::
    ExtensionExtFeatureMetadataStatisticsReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataStatisticsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataStatisticsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataStatistics>
ExtensionExtFeatureMetadataStatisticsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataStatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataStatistics>
ExtensionExtFeatureMetadataStatisticsReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataStatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataStatistics>>
ExtensionExtFeatureMetadataStatisticsReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataStatistics,
      ExtensionExtFeatureMetadataStatisticsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataClassStatisticsJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataClassStatistics.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataClassStatisticsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataClassStatisticsJsonHandler::
    ExtensionExtFeatureMetadataClassStatisticsJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _count(),
      _properties(options) {}

void ExtensionExtFeatureMetadataClassStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataClassStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataClassStatisticsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataClassStatistics(
      CesiumGltf::ExtensionExtFeatureMetadataClassStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataClassStatisticsJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataClassStatistics(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataClassStatistics& o) {
  using namespace std::string_literals;

  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataClassStatisticsReader::
    ExtensionExtFeatureMetadataClassStatisticsReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataClassStatisticsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataClassStatisticsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataClassStatistics>
ExtensionExtFeatureMetadataClassStatisticsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataClassStatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataClassStatistics>
ExtensionExtFeatureMetadataClassStatisticsReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataClassStatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataClassStatistics>>
ExtensionExtFeatureMetadataClassStatisticsReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataClassStatistics,
      ExtensionExtFeatureMetadataClassStatisticsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataPropertyStatisticsJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataPropertyStatistics.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataPropertyStatisticsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataPropertyStatisticsJsonHandler::
    ExtensionExtFeatureMetadataPropertyStatisticsJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _min(),
      _max(),
      _mean(),
      _median(),
      _standardDeviation(),
      _variance(),
      _sum(),
      _occurrences() {}

void ExtensionExtFeatureMetadataPropertyStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataPropertyStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataPropertyStatisticsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataPropertyStatistics(
      CesiumGltf::ExtensionExtFeatureMetadataPropertyStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataPropertyStatisticsJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataPropertyStatistics(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataPropertyStatistics& o) {
  using namespace std::string_literals;

  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("mean"s == str)
    return property("mean", this->_mean, o.mean);
  if ("median"s == str)
    return property("median", this->_median, o.median);
  if ("standardDeviation"s == str)
    return property(
        "standardDeviation",
        this->_standardDeviation,
        o.standardDeviation);
  if ("variance"s == str)
    return property("variance", this->_variance, o.variance);
  if ("sum"s == str)
    return property("sum", this->_sum, o.sum);
  if ("occurrences"s == str)
    return property("occurrences", this->_occurrences, o.occurrences);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataPropertyStatisticsReader::
    ExtensionExtFeatureMetadataPropertyStatisticsReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataPropertyStatisticsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataPropertyStatisticsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataPropertyStatistics>
ExtensionExtFeatureMetadataPropertyStatisticsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataPropertyStatisticsJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataPropertyStatistics>
ExtensionExtFeatureMetadataPropertyStatisticsReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataPropertyStatisticsJsonHandler handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataPropertyStatistics>>
ExtensionExtFeatureMetadataPropertyStatisticsReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataPropertyStatistics,
      ExtensionExtFeatureMetadataPropertyStatisticsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataSchemaJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataSchema.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataSchemaReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataSchemaJsonHandler::
    ExtensionExtFeatureMetadataSchemaJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _version(),
      _classes(options),
      _enums(options) {}

void ExtensionExtFeatureMetadataSchemaJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataSchema* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataSchemaJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataSchema(
      CesiumGltf::ExtensionExtFeatureMetadataSchema::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ExtensionExtFeatureMetadataSchemaJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataSchema(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataSchema& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);
  if ("enums"s == str)
    return property("enums", this->_enums, o.enums);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataSchemaReader::
    ExtensionExtFeatureMetadataSchemaReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataSchemaReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataSchemaReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtFeatureMetadataSchema>
ExtensionExtFeatureMetadataSchemaReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataSchemaJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtFeatureMetadataSchema>
ExtensionExtFeatureMetadataSchemaReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataSchemaJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataSchema>>
ExtensionExtFeatureMetadataSchemaReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataSchema,
      ExtensionExtFeatureMetadataSchemaJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataEnumJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataEnum.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataEnumReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataEnumJsonHandler::
    ExtensionExtFeatureMetadataEnumJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _valueType(),
      _values(options) {}

void ExtensionExtFeatureMetadataEnumJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataEnum* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataEnumJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataEnum(
      CesiumGltf::ExtensionExtFeatureMetadataEnum::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ExtensionExtFeatureMetadataEnumJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataEnum(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataEnum& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("valueType"s == str)
    return property("valueType", this->_valueType, o.valueType);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataEnumReader::ExtensionExtFeatureMetadataEnumReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataEnumReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataEnumReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtFeatureMetadataEnum>
ExtensionExtFeatureMetadataEnumReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataEnumJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtFeatureMetadataEnum>
ExtensionExtFeatureMetadataEnumReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataEnumJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataEnum>>
ExtensionExtFeatureMetadataEnumReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataEnum,
      ExtensionExtFeatureMetadataEnumJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataEnumValueJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataEnumValue.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataEnumValueReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataEnumValueJsonHandler::
    ExtensionExtFeatureMetadataEnumValueJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _value() {}

void ExtensionExtFeatureMetadataEnumValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataEnumValue* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataEnumValueJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataEnumValue(
      CesiumGltf::ExtensionExtFeatureMetadataEnumValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataEnumValueJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataEnumValue(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataEnumValue& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("value"s == str)
    return property("value", this->_value, o.value);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataEnumValueReader::
    ExtensionExtFeatureMetadataEnumValueReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataEnumValueReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataEnumValueReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataEnumValue>
ExtensionExtFeatureMetadataEnumValueReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataEnumValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataEnumValue>
ExtensionExtFeatureMetadataEnumValueReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataEnumValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataEnumValue>>
ExtensionExtFeatureMetadataEnumValueReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataEnumValue,
      ExtensionExtFeatureMetadataEnumValueJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataClassJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataClass.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataClassReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataClassJsonHandler::
    ExtensionExtFeatureMetadataClassJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _properties(options) {}

void ExtensionExtFeatureMetadataClassJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataClass* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataClassJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataClass(
      CesiumGltf::ExtensionExtFeatureMetadataClass::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ExtensionExtFeatureMetadataClassJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataClass(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataClass& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataClassReader::
    ExtensionExtFeatureMetadataClassReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataClassReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataClassReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtFeatureMetadataClass>
ExtensionExtFeatureMetadataClassReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataClassJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::ExtensionExtFeatureMetadataClass>
ExtensionExtFeatureMetadataClassReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataClassJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataClass>>
ExtensionExtFeatureMetadataClassReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataClass,
      ExtensionExtFeatureMetadataClassJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtFeatureMetadataClassPropertyJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/ExtensionExtFeatureMetadataClassProperty.h>
#include <CesiumGltfReader/ExtensionExtFeatureMetadataClassPropertyReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtFeatureMetadataClassPropertyJsonHandler::
    ExtensionExtFeatureMetadataClassPropertyJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _type(),
      _enumType(),
      _componentType(),
      _componentCount(),
      _normalized(),
      _max(),
      _min(),
      _defaultProperty(),
      _optional(),
      _semantic() {}

void ExtensionExtFeatureMetadataClassPropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtFeatureMetadataClassProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataClassPropertyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtFeatureMetadataClassProperty(
      CesiumGltf::ExtensionExtFeatureMetadataClassProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtFeatureMetadataClassPropertyJsonHandler::
    readObjectKeyExtensionExtFeatureMetadataClassProperty(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtFeatureMetadataClassProperty& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("enumType"s == str)
    return property("enumType", this->_enumType, o.enumType);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("componentCount"s == str)
    return property("componentCount", this->_componentCount, o.componentCount);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("default"s == str)
    return property("default", this->_defaultProperty, o.defaultProperty);
  if ("optional"s == str)
    return property("optional", this->_optional, o.optional);
  if ("semantic"s == str)
    return property("semantic", this->_semantic, o.semantic);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ExtensionExtFeatureMetadataClassPropertyReader::
    ExtensionExtFeatureMetadataClassPropertyReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataClassPropertyReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ExtensionExtFeatureMetadataClassPropertyReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataClassProperty>
ExtensionExtFeatureMetadataClassPropertyReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ExtensionExtFeatureMetadataClassPropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    CesiumGltf::ExtensionExtFeatureMetadataClassProperty>
ExtensionExtFeatureMetadataClassPropertyReader::readFromJson(
    const rapidjson::Value& value) const {
  ExtensionExtFeatureMetadataClassPropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::ExtensionExtFeatureMetadataClassProperty>>
ExtensionExtFeatureMetadataClassPropertyReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::ExtensionExtFeatureMetadataClassProperty,
      ExtensionExtFeatureMetadataClassPropertyJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ModelJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Model.h>
#include <CesiumGltfReader/ModelReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ModelJsonHandler::ModelJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _extensionsUsed(),
      _extensionsRequired(),
      _accessors(options),
      _animations(options),
      _asset(options),
      _buffers(options),
      _bufferViews(options),
      _cameras(options),
      _images(options),
      _materials(options),
      _meshes(options),
      _nodes(options),
      _samplers(options),
      _scene(),
      _scenes(options),
      _skins(options),
      _textures(options) {}

void ModelJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Model* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ModelJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyModel(
      CesiumGltf::Model::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ModelJsonHandler::readObjectKeyModel(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Model& o) {
  using namespace std::string_literals;

  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);
  if ("accessors"s == str)
    return property("accessors", this->_accessors, o.accessors);
  if ("animations"s == str)
    return property("animations", this->_animations, o.animations);
  if ("asset"s == str)
    return property("asset", this->_asset, o.asset);
  if ("buffers"s == str)
    return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str)
    return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("cameras"s == str)
    return property("cameras", this->_cameras, o.cameras);
  if ("images"s == str)
    return property("images", this->_images, o.images);
  if ("materials"s == str)
    return property("materials", this->_materials, o.materials);
  if ("meshes"s == str)
    return property("meshes", this->_meshes, o.meshes);
  if ("nodes"s == str)
    return property("nodes", this->_nodes, o.nodes);
  if ("samplers"s == str)
    return property("samplers", this->_samplers, o.samplers);
  if ("scene"s == str)
    return property("scene", this->_scene, o.scene);
  if ("scenes"s == str)
    return property("scenes", this->_scenes, o.scenes);
  if ("skins"s == str)
    return property("skins", this->_skins, o.skins);
  if ("textures"s == str)
    return property("textures", this->_textures, o.textures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ModelReader::ModelReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& ModelReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& ModelReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Model>
ModelReader::readFromJson(const gsl::span<const std::byte>& data) const {
  ModelJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Model>
ModelReader::readFromJson(const rapidjson::Value& value) const {
  ModelJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Model>>
ModelReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Model, ModelJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TextureJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Texture.h>
#include <CesiumGltfReader/TextureReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

TextureJsonHandler::TextureJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _sampler(),
      _source() {}

void TextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Texture* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTexture(
      CesiumGltf::Texture::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TextureJsonHandler::readObjectKeyTexture(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Texture& o) {
  using namespace std::string_literals;

  if ("sampler"s == str)
    return property("sampler", this->_sampler, o.sampler);
  if ("source"s == str)
    return property("source", this->_source, o.source);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

TextureReader::TextureReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& TextureReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& TextureReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Texture>
TextureReader::readFromJson(const gsl::span<const std::byte>& data) const {
  TextureJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Texture>
TextureReader::readFromJson(const rapidjson::Value& value) const {
  TextureJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Texture>>
TextureReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Texture, TextureJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SkinJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Skin.h>
#include <CesiumGltfReader/SkinReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

SkinJsonHandler::SkinJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _inverseBindMatrices(),
      _skeleton(),
      _joints() {}

void SkinJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Skin* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SkinJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySkin(
      CesiumGltf::Skin::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SkinJsonHandler::readObjectKeySkin(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Skin& o) {
  using namespace std::string_literals;

  if ("inverseBindMatrices"s == str)
    return property(
        "inverseBindMatrices",
        this->_inverseBindMatrices,
        o.inverseBindMatrices);
  if ("skeleton"s == str)
    return property("skeleton", this->_skeleton, o.skeleton);
  if ("joints"s == str)
    return property("joints", this->_joints, o.joints);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

SkinReader::SkinReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& SkinReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& SkinReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Skin>
SkinReader::readFromJson(const gsl::span<const std::byte>& data) const {
  SkinJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Skin>
SkinReader::readFromJson(const rapidjson::Value& value) const {
  SkinJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Skin>>
SkinReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Skin, SkinJsonHandler> handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SceneJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Scene.h>
#include <CesiumGltfReader/SceneReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

SceneJsonHandler::SceneJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options), _nodes() {}

void SceneJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Scene* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SceneJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyScene(
      CesiumGltf::Scene::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SceneJsonHandler::readObjectKeyScene(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Scene& o) {
  using namespace std::string_literals;

  if ("nodes"s == str)
    return property("nodes", this->_nodes, o.nodes);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

SceneReader::SceneReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& SceneReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& SceneReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Scene>
SceneReader::readFromJson(const gsl::span<const std::byte>& data) const {
  SceneJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Scene>
SceneReader::readFromJson(const rapidjson::Value& value) const {
  SceneJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Scene>>
SceneReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Scene, SceneJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SamplerJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Sampler.h>
#include <CesiumGltfReader/SamplerReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

SamplerJsonHandler::SamplerJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _magFilter(),
      _minFilter(),
      _wrapS(),
      _wrapT() {}

void SamplerJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Sampler* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SamplerJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySampler(
      CesiumGltf::Sampler::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SamplerJsonHandler::readObjectKeySampler(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Sampler& o) {
  using namespace std::string_literals;

  if ("magFilter"s == str)
    return property("magFilter", this->_magFilter, o.magFilter);
  if ("minFilter"s == str)
    return property("minFilter", this->_minFilter, o.minFilter);
  if ("wrapS"s == str)
    return property("wrapS", this->_wrapS, o.wrapS);
  if ("wrapT"s == str)
    return property("wrapT", this->_wrapT, o.wrapT);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

SamplerReader::SamplerReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& SamplerReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& SamplerReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Sampler>
SamplerReader::readFromJson(const gsl::span<const std::byte>& data) const {
  SamplerJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Sampler>
SamplerReader::readFromJson(const rapidjson::Value& value) const {
  SamplerJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Sampler>>
SamplerReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Sampler, SamplerJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "NodeJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Node.h>
#include <CesiumGltfReader/NodeReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

NodeJsonHandler::NodeJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _camera(),
      _children(),
      _skin(),
      _matrix(),
      _mesh(),
      _rotation(),
      _scale(),
      _translation(),
      _weights() {}

void NodeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Node* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
NodeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyNode(
      CesiumGltf::Node::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* NodeJsonHandler::readObjectKeyNode(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Node& o) {
  using namespace std::string_literals;

  if ("camera"s == str)
    return property("camera", this->_camera, o.camera);
  if ("children"s == str)
    return property("children", this->_children, o.children);
  if ("skin"s == str)
    return property("skin", this->_skin, o.skin);
  if ("matrix"s == str)
    return property("matrix", this->_matrix, o.matrix);
  if ("mesh"s == str)
    return property("mesh", this->_mesh, o.mesh);
  if ("rotation"s == str)
    return property("rotation", this->_rotation, o.rotation);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("translation"s == str)
    return property("translation", this->_translation, o.translation);
  if ("weights"s == str)
    return property("weights", this->_weights, o.weights);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

NodeReader::NodeReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& NodeReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& NodeReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Node>
NodeReader::readFromJson(const gsl::span<const std::byte>& data) const {
  NodeJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Node>
NodeReader::readFromJson(const rapidjson::Value& value) const {
  NodeJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Node>>
NodeReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Node, NodeJsonHandler> handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MeshJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Mesh.h>
#include <CesiumGltfReader/MeshReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MeshJsonHandler::MeshJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _primitives(options),
      _weights() {}

void MeshJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Mesh* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MeshJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMesh(
      CesiumGltf::Mesh::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MeshJsonHandler::readObjectKeyMesh(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Mesh& o) {
  using namespace std::string_literals;

  if ("primitives"s == str)
    return property("primitives", this->_primitives, o.primitives);
  if ("weights"s == str)
    return property("weights", this->_weights, o.weights);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

MeshReader::MeshReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& MeshReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& MeshReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Mesh>
MeshReader::readFromJson(const gsl::span<const std::byte>& data) const {
  MeshJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Mesh>
MeshReader::readFromJson(const rapidjson::Value& value) const {
  MeshJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Mesh>>
MeshReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Mesh, MeshJsonHandler> handler(
      this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MeshPrimitiveJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/MeshPrimitive.h>
#include <CesiumGltfReader/MeshPrimitiveReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MeshPrimitiveJsonHandler::MeshPrimitiveJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _attributes(),
      _indices(),
      _material(),
      _mode(),
      _targets() {}

void MeshPrimitiveJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::MeshPrimitive* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MeshPrimitiveJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMeshPrimitive(
      CesiumGltf::MeshPrimitive::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
MeshPrimitiveJsonHandler::readObjectKeyMeshPrimitive(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::MeshPrimitive& o) {
  using namespace std::string_literals;

  if ("attributes"s == str)
    return property("attributes", this->_attributes, o.attributes);
  if ("indices"s == str)
    return property("indices", this->_indices, o.indices);
  if ("material"s == str)
    return property("material", this->_material, o.material);
  if ("mode"s == str)
    return property("mode", this->_mode, o.mode);
  if ("targets"s == str)
    return property("targets", this->_targets, o.targets);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

MeshPrimitiveReader::MeshPrimitiveReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& MeshPrimitiveReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
MeshPrimitiveReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::MeshPrimitive>
MeshPrimitiveReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  MeshPrimitiveJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::MeshPrimitive>
MeshPrimitiveReader::readFromJson(const rapidjson::Value& value) const {
  MeshPrimitiveJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::MeshPrimitive>>
MeshPrimitiveReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::MeshPrimitive, MeshPrimitiveJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Material.h>
#include <CesiumGltfReader/MaterialReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MaterialJsonHandler::MaterialJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _pbrMetallicRoughness(options),
      _normalTexture(options),
      _occlusionTexture(options),
      _emissiveTexture(options),
      _emissiveFactor(),
      _alphaMode(),
      _alphaCutoff(),
      _doubleSided() {}

void MaterialJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Material* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterial(
      CesiumGltf::Material::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialJsonHandler::readObjectKeyMaterial(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Material& o) {
  using namespace std::string_literals;

  if ("pbrMetallicRoughness"s == str)
    return property(
        "pbrMetallicRoughness",
        this->_pbrMetallicRoughness,
        o.pbrMetallicRoughness);
  if ("normalTexture"s == str)
    return property("normalTexture", this->_normalTexture, o.normalTexture);
  if ("occlusionTexture"s == str)
    return property(
        "occlusionTexture",
        this->_occlusionTexture,
        o.occlusionTexture);
  if ("emissiveTexture"s == str)
    return property(
        "emissiveTexture",
        this->_emissiveTexture,
        o.emissiveTexture);
  if ("emissiveFactor"s == str)
    return property("emissiveFactor", this->_emissiveFactor, o.emissiveFactor);
  if ("alphaMode"s == str)
    return property("alphaMode", this->_alphaMode, o.alphaMode);
  if ("alphaCutoff"s == str)
    return property("alphaCutoff", this->_alphaCutoff, o.alphaCutoff);
  if ("doubleSided"s == str)
    return property("doubleSided", this->_doubleSided, o.doubleSided);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

MaterialReader::MaterialReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& MaterialReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& MaterialReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Material>
MaterialReader::readFromJson(const gsl::span<const std::byte>& data) const {
  MaterialJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Material>
MaterialReader::readFromJson(const rapidjson::Value& value) const {
  MaterialJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Material>>
MaterialReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Material, MaterialJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialOcclusionTextureInfoJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/MaterialOcclusionTextureInfo.h>
#include <CesiumGltfReader/MaterialOcclusionTextureInfoReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MaterialOcclusionTextureInfoJsonHandler::
    MaterialOcclusionTextureInfoJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : TextureInfoJsonHandler(options), _strength() {}

void MaterialOcclusionTextureInfoJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::MaterialOcclusionTextureInfo* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialOcclusionTextureInfoJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialOcclusionTextureInfo(
      CesiumGltf::MaterialOcclusionTextureInfo::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialOcclusionTextureInfoJsonHandler::
    readObjectKeyMaterialOcclusionTextureInfo(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::MaterialOcclusionTextureInfo& o) {
  using namespace std::string_literals;

  if ("strength"s == str)
    return property("strength", this->_strength, o.strength);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}

MaterialOcclusionTextureInfoReader::MaterialOcclusionTextureInfoReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
MaterialOcclusionTextureInfoReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
MaterialOcclusionTextureInfoReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::MaterialOcclusionTextureInfo>
MaterialOcclusionTextureInfoReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  MaterialOcclusionTextureInfoJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::MaterialOcclusionTextureInfo>
MaterialOcclusionTextureInfoReader::readFromJson(
    const rapidjson::Value& value) const {
  MaterialOcclusionTextureInfoJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::MaterialOcclusionTextureInfo>>
MaterialOcclusionTextureInfoReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::MaterialOcclusionTextureInfo,
      MaterialOcclusionTextureInfoJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialNormalTextureInfoJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/MaterialNormalTextureInfo.h>
#include <CesiumGltfReader/MaterialNormalTextureInfoReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MaterialNormalTextureInfoJsonHandler::MaterialNormalTextureInfoJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : TextureInfoJsonHandler(options), _scale() {}

void MaterialNormalTextureInfoJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::MaterialNormalTextureInfo* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialNormalTextureInfoJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialNormalTextureInfo(
      CesiumGltf::MaterialNormalTextureInfo::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
MaterialNormalTextureInfoJsonHandler::readObjectKeyMaterialNormalTextureInfo(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::MaterialNormalTextureInfo& o) {
  using namespace std::string_literals;

  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}

MaterialNormalTextureInfoReader::MaterialNormalTextureInfoReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
MaterialNormalTextureInfoReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
MaterialNormalTextureInfoReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::MaterialNormalTextureInfo>
MaterialNormalTextureInfoReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  MaterialNormalTextureInfoJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::MaterialNormalTextureInfo>
MaterialNormalTextureInfoReader::readFromJson(
    const rapidjson::Value& value) const {
  MaterialNormalTextureInfoJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::MaterialNormalTextureInfo>>
MaterialNormalTextureInfoReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::MaterialNormalTextureInfo,
      MaterialNormalTextureInfoJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialPBRMetallicRoughnessJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/MaterialPBRMetallicRoughness.h>
#include <CesiumGltfReader/MaterialPBRMetallicRoughnessReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MaterialPBRMetallicRoughnessJsonHandler::
    MaterialPBRMetallicRoughnessJsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _baseColorFactor(),
      _baseColorTexture(options),
      _metallicFactor(),
      _roughnessFactor(),
      _metallicRoughnessTexture(options) {}

void MaterialPBRMetallicRoughnessJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::MaterialPBRMetallicRoughness* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialPBRMetallicRoughnessJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialPBRMetallicRoughness(
      CesiumGltf::MaterialPBRMetallicRoughness::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialPBRMetallicRoughnessJsonHandler::
    readObjectKeyMaterialPBRMetallicRoughness(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::MaterialPBRMetallicRoughness& o) {
  using namespace std::string_literals;

  if ("baseColorFactor"s == str)
    return property(
        "baseColorFactor",
        this->_baseColorFactor,
        o.baseColorFactor);
  if ("baseColorTexture"s == str)
    return property(
        "baseColorTexture",
        this->_baseColorTexture,
        o.baseColorTexture);
  if ("metallicFactor"s == str)
    return property("metallicFactor", this->_metallicFactor, o.metallicFactor);
  if ("roughnessFactor"s == str)
    return property(
        "roughnessFactor",
        this->_roughnessFactor,
        o.roughnessFactor);
  if ("metallicRoughnessTexture"s == str)
    return property(
        "metallicRoughnessTexture",
        this->_metallicRoughnessTexture,
        o.metallicRoughnessTexture);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

MaterialPBRMetallicRoughnessReader::MaterialPBRMetallicRoughnessReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
MaterialPBRMetallicRoughnessReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
MaterialPBRMetallicRoughnessReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::MaterialPBRMetallicRoughness>
MaterialPBRMetallicRoughnessReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  MaterialPBRMetallicRoughnessJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::MaterialPBRMetallicRoughness>
MaterialPBRMetallicRoughnessReader::readFromJson(
    const rapidjson::Value& value) const {
  MaterialPBRMetallicRoughnessJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::MaterialPBRMetallicRoughness>>
MaterialPBRMetallicRoughnessReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::MaterialPBRMetallicRoughness,
      MaterialPBRMetallicRoughnessJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ImageJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Image.h>
#include <CesiumGltfReader/ImageReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ImageJsonHandler::ImageJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _uri(),
      _mimeType(),
      _bufferView() {}

void ImageJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Image* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ImageJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyImage(
      CesiumGltf::Image::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ImageJsonHandler::readObjectKeyImage(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Image& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("mimeType"s == str)
    return property("mimeType", this->_mimeType, o.mimeType);
  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

ImageReader::ImageReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& ImageReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& ImageReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Image>
ImageReader::readFromJson(const gsl::span<const std::byte>& data) const {
  ImageJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Image>
ImageReader::readFromJson(const rapidjson::Value& value) const {
  ImageJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Image>>
ImageReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Image, ImageJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "CameraJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Camera.h>
#include <CesiumGltfReader/CameraReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

CameraJsonHandler::CameraJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _orthographic(options),
      _perspective(options),
      _type() {}

void CameraJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Camera* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
CameraJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCamera(
      CesiumGltf::Camera::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* CameraJsonHandler::readObjectKeyCamera(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Camera& o) {
  using namespace std::string_literals;

  if ("orthographic"s == str)
    return property("orthographic", this->_orthographic, o.orthographic);
  if ("perspective"s == str)
    return property("perspective", this->_perspective, o.perspective);
  if ("type"s == str)
    return property("type", this->_type, o.type);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

CameraReader::CameraReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& CameraReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& CameraReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Camera>
CameraReader::readFromJson(const gsl::span<const std::byte>& data) const {
  CameraJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Camera>
CameraReader::readFromJson(const rapidjson::Value& value) const {
  CameraJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Camera>>
CameraReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Camera, CameraJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "CameraPerspectiveJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/CameraPerspective.h>
#include <CesiumGltfReader/CameraPerspectiveReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

CameraPerspectiveJsonHandler::CameraPerspectiveJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _aspectRatio(),
      _yfov(),
      _zfar(),
      _znear() {}

void CameraPerspectiveJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::CameraPerspective* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
CameraPerspectiveJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCameraPerspective(
      CesiumGltf::CameraPerspective::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
CameraPerspectiveJsonHandler::readObjectKeyCameraPerspective(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::CameraPerspective& o) {
  using namespace std::string_literals;

  if ("aspectRatio"s == str)
    return property("aspectRatio", this->_aspectRatio, o.aspectRatio);
  if ("yfov"s == str)
    return property("yfov", this->_yfov, o.yfov);
  if ("zfar"s == str)
    return property("zfar", this->_zfar, o.zfar);
  if ("znear"s == str)
    return property("znear", this->_znear, o.znear);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

CameraPerspectiveReader::CameraPerspectiveReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& CameraPerspectiveReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
CameraPerspectiveReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::CameraPerspective>
CameraPerspectiveReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  CameraPerspectiveJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::CameraPerspective>
CameraPerspectiveReader::readFromJson(const rapidjson::Value& value) const {
  CameraPerspectiveJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::CameraPerspective>>
CameraPerspectiveReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::CameraPerspective,
      CameraPerspectiveJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "CameraOrthographicJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/CameraOrthographic.h>
#include <CesiumGltfReader/CameraOrthographicReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

CameraOrthographicJsonHandler::CameraOrthographicJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _xmag(),
      _ymag(),
      _zfar(),
      _znear() {}

void CameraOrthographicJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::CameraOrthographic* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
CameraOrthographicJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCameraOrthographic(
      CesiumGltf::CameraOrthographic::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
CameraOrthographicJsonHandler::readObjectKeyCameraOrthographic(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::CameraOrthographic& o) {
  using namespace std::string_literals;

  if ("xmag"s == str)
    return property("xmag", this->_xmag, o.xmag);
  if ("ymag"s == str)
    return property("ymag", this->_ymag, o.ymag);
  if ("zfar"s == str)
    return property("zfar", this->_zfar, o.zfar);
  if ("znear"s == str)
    return property("znear", this->_znear, o.znear);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

CameraOrthographicReader::CameraOrthographicReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& CameraOrthographicReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
CameraOrthographicReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::CameraOrthographic>
CameraOrthographicReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  CameraOrthographicJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::CameraOrthographic>
CameraOrthographicReader::readFromJson(const rapidjson::Value& value) const {
  CameraOrthographicJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::CameraOrthographic>>
CameraOrthographicReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::CameraOrthographic,
      CameraOrthographicJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferViewJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/BufferView.h>
#include <CesiumGltfReader/BufferViewReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

BufferViewJsonHandler::BufferViewJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _byteStride(),
      _target() {}

void BufferViewJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::BufferView* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferViewJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBufferView(
      CesiumGltf::BufferView::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKeyBufferView(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::BufferView& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("byteStride"s == str)
    return property("byteStride", this->_byteStride, o.byteStride);
  if ("target"s == str)
    return property("target", this->_target, o.target);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

BufferViewReader::BufferViewReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& BufferViewReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
BufferViewReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::BufferView>
BufferViewReader::readFromJson(const gsl::span<const std::byte>& data) const {
  BufferViewJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::BufferView>
BufferViewReader::readFromJson(const rapidjson::Value& value) const {
  BufferViewJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::BufferView>>
BufferViewReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::BufferView, BufferViewJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Buffer.h>
#include <CesiumGltfReader/BufferReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

BufferJsonHandler::BufferJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _uri(),
      _byteLength() {}

void BufferJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Buffer* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBuffer(
      CesiumGltf::Buffer::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKeyBuffer(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Buffer& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

BufferReader::BufferReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& BufferReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& BufferReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Buffer>
BufferReader::readFromJson(const gsl::span<const std::byte>& data) const {
  BufferJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Buffer>
BufferReader::readFromJson(const rapidjson::Value& value) const {
  BufferJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Buffer>>
BufferReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Buffer, BufferJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AssetJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Asset.h>
#include <CesiumGltfReader/AssetReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AssetJsonHandler::AssetJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _copyright(),
      _generator(),
      _version(),
      _minVersion() {}

void AssetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Asset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AssetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAsset(
      CesiumGltf::Asset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKeyAsset(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Asset& o) {
  using namespace std::string_literals;

  if ("copyright"s == str)
    return property("copyright", this->_copyright, o.copyright);
  if ("generator"s == str)
    return property("generator", this->_generator, o.generator);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("minVersion"s == str)
    return property("minVersion", this->_minVersion, o.minVersion);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

AssetReader::AssetReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& AssetReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& AssetReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Asset>
AssetReader::readFromJson(const gsl::span<const std::byte>& data) const {
  AssetJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Asset>
AssetReader::readFromJson(const rapidjson::Value& value) const {
  AssetJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Asset>>
AssetReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Asset, AssetJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Animation.h>
#include <CesiumGltfReader/AnimationReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AnimationJsonHandler::AnimationJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _channels(options),
      _samplers(options) {}

void AnimationJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Animation* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimation(
      CesiumGltf::Animation::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AnimationJsonHandler::readObjectKeyAnimation(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Animation& o) {
  using namespace std::string_literals;

  if ("channels"s == str)
    return property("channels", this->_channels, o.channels);
  if ("samplers"s == str)
    return property("samplers", this->_samplers, o.samplers);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

AnimationReader::AnimationReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& AnimationReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& AnimationReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Animation>
AnimationReader::readFromJson(const gsl::span<const std::byte>& data) const {
  AnimationJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Animation>
AnimationReader::readFromJson(const rapidjson::Value& value) const {
  AnimationJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Animation>>
AnimationReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::Animation, AnimationJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationSamplerJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/AnimationSampler.h>
#include <CesiumGltfReader/AnimationSamplerReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AnimationSamplerJsonHandler::AnimationSamplerJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _input(),
      _interpolation(),
      _output() {}

void AnimationSamplerJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AnimationSampler* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationSamplerJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationSampler(
      CesiumGltf::AnimationSampler::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AnimationSamplerJsonHandler::readObjectKeyAnimationSampler(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AnimationSampler& o) {
  using namespace std::string_literals;

  if ("input"s == str)
    return property("input", this->_input, o.input);
  if ("interpolation"s == str)
    return property("interpolation", this->_interpolation, o.interpolation);
  if ("output"s == str)
    return property("output", this->_output, o.output);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

AnimationSamplerReader::AnimationSamplerReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& AnimationSamplerReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
AnimationSamplerReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AnimationSampler>
AnimationSamplerReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  AnimationSamplerJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AnimationSampler>
AnimationSamplerReader::readFromJson(const rapidjson::Value& value) const {
  AnimationSamplerJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::AnimationSampler>>
AnimationSamplerReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::AnimationSampler,
      AnimationSamplerJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationChannelJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/AnimationChannel.h>
#include <CesiumGltfReader/AnimationChannelReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AnimationChannelJsonHandler::AnimationChannelJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _sampler(),
      _target(options) {}

void AnimationChannelJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AnimationChannel* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationChannelJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationChannel(
      CesiumGltf::AnimationChannel::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AnimationChannelJsonHandler::readObjectKeyAnimationChannel(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AnimationChannel& o) {
  using namespace std::string_literals;

  if ("sampler"s == str)
    return property("sampler", this->_sampler, o.sampler);
  if ("target"s == str)
    return property("target", this->_target, o.target);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

AnimationChannelReader::AnimationChannelReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& AnimationChannelReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
AnimationChannelReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AnimationChannel>
AnimationChannelReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  AnimationChannelJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AnimationChannel>
AnimationChannelReader::readFromJson(const rapidjson::Value& value) const {
  AnimationChannelJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::AnimationChannel>>
AnimationChannelReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::AnimationChannel,
      AnimationChannelJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationChannelTargetJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/AnimationChannelTarget.h>
#include <CesiumGltfReader/AnimationChannelTargetReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AnimationChannelTargetJsonHandler::AnimationChannelTargetJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _node(),
      _path() {}

void AnimationChannelTargetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AnimationChannelTarget* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationChannelTargetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationChannelTarget(
      CesiumGltf::AnimationChannelTarget::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AnimationChannelTargetJsonHandler::readObjectKeyAnimationChannelTarget(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AnimationChannelTarget& o) {
  using namespace std::string_literals;

  if ("node"s == str)
    return property("node", this->_node, o.node);
  if ("path"s == str)
    return property("path", this->_path, o.path);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

AnimationChannelTargetReader::AnimationChannelTargetReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
AnimationChannelTargetReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
AnimationChannelTargetReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AnimationChannelTarget>
AnimationChannelTargetReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  AnimationChannelTargetJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AnimationChannelTarget>
AnimationChannelTargetReader::readFromJson(
    const rapidjson::Value& value) const {
  AnimationChannelTargetJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<CesiumGltf::AnimationChannelTarget>>
AnimationChannelTargetReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::AnimationChannelTarget,
      AnimationChannelTargetJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/Accessor.h>
#include <CesiumGltfReader/AccessorReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AccessorJsonHandler::AccessorJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(options),
      _bufferView(),
      _byteOffset(),
      _componentType(),
      _normalized(),
      _count(),
      _type(),
      _max(),
      _min(),
      _sparse(options) {}

void AccessorJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Accessor* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessor(
      CesiumGltf::Accessor::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AccessorJsonHandler::readObjectKeyAccessor(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Accessor& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("sparse"s == str)
    return property("sparse", this->_sparse, o.sparse);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

AccessorReader::AccessorReader() { registerExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& AccessorReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& AccessorReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Accessor>
AccessorReader::readFromJson(const gsl::span<const std::byte>& data) const {
  AccessorJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::Accessor>
AccessorReader::readFromJson(const rapidjson::Value& value) const {
  AccessorJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::Accessor>>
AccessorReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<CesiumGltf::Accessor, AccessorJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/AccessorSparse.h>
#include <CesiumGltfReader/AccessorSparseReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AccessorSparseJsonHandler::AccessorSparseJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _count(),
      _indices(options),
      _values(options) {}

void AccessorSparseJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AccessorSparse* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorSparseJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparse(
      CesiumGltf::AccessorSparse::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AccessorSparseJsonHandler::readObjectKeyAccessorSparse(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AccessorSparse& o) {
  using namespace std::string_literals;

  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("indices"s == str)
    return property("indices", this->_indices, o.indices);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

AccessorSparseReader::AccessorSparseReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& AccessorSparseReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
AccessorSparseReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AccessorSparse>
AccessorSparseReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  AccessorSparseJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AccessorSparse>
AccessorSparseReader::readFromJson(const rapidjson::Value& value) const {
  AccessorSparseJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::AccessorSparse>>
AccessorSparseReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<CesiumGltf::AccessorSparse, AccessorSparseJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseValuesJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/AccessorSparseValues.h>
#include <CesiumGltfReader/AccessorSparseValuesReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AccessorSparseValuesJsonHandler::AccessorSparseValuesJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _bufferView(),
      _byteOffset() {}

void AccessorSparseValuesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AccessorSparseValues* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorSparseValuesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparseValues(
      CesiumGltf::AccessorSparseValues::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AccessorSparseValuesJsonHandler::readObjectKeyAccessorSparseValues(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AccessorSparseValues& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

AccessorSparseValuesReader::AccessorSparseValuesReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& AccessorSparseValuesReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
AccessorSparseValuesReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AccessorSparseValues>
AccessorSparseValuesReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  AccessorSparseValuesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AccessorSparseValues>
AccessorSparseValuesReader::readFromJson(const rapidjson::Value& value) const {
  AccessorSparseValuesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::AccessorSparseValues>>
AccessorSparseValuesReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::AccessorSparseValues,
      AccessorSparseValuesJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseIndicesJsonHandler.h"
#include "registerExtensions.h"

#include <CesiumGltf/AccessorSparseIndices.h>
#include <CesiumGltfReader/AccessorSparseIndicesReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AccessorSparseIndicesJsonHandler::AccessorSparseIndicesJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _bufferView(),
      _byteOffset(),
      _componentType() {}

void AccessorSparseIndicesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AccessorSparseIndices* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorSparseIndicesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparseIndices(
      CesiumGltf::AccessorSparseIndices::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AccessorSparseIndicesJsonHandler::readObjectKeyAccessorSparseIndices(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AccessorSparseIndices& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

AccessorSparseIndicesReader::AccessorSparseIndicesReader() {
  registerExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& AccessorSparseIndicesReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
AccessorSparseIndicesReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AccessorSparseIndices>
AccessorSparseIndicesReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  AccessorSparseIndicesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<CesiumGltf::AccessorSparseIndices>
AccessorSparseIndicesReader::readFromJson(const rapidjson::Value& value) const {
  AccessorSparseIndicesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<CesiumGltf::AccessorSparseIndices>>
AccessorSparseIndicesReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      CesiumGltf::AccessorSparseIndices,
      AccessorSparseIndicesJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace CesiumGltfReader
