/*--------------------------------------------------------------------------------------+
|
|     $Source: GltfTuner.cpp $
|
|  $Copyright: (c) 2024 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/

#include <BeUtils/Gltf/GltfTuner.h>
#include <CesiumGltf/ExtensionModelExtStructuralMetadata.h>
#include <CesiumGltf/AccessorView.h>
#include <boost/pfr/functors.hpp>
#include <CesiumGltf/ExtensionExtMeshFeatures.h>
#include <boost/mpl/set.hpp>
#include <boost/mpl/front.hpp>
#include <BeUtils/Gltf/GltfBuilder.h>

namespace BeUtils
{

namespace
{

//! This namespace contains utilities to create a set of (fully typed) AccessorViews.
//! This is used when processing primitives.
namespace AccessorViews
{

struct Empty
{
};

//! Used to create an AccessorView.
template<template<class> class _ViewHolder>
struct Maker
{
	template<class _T>
	using ViewHolder = _ViewHolder<_T>;
	int32_t index_ = -1;
	template<class _T, class _Super>
	struct Type: _ViewHolder<CesiumGltf::AccessorView<_T>>, _Super
	{
	};
	template<class _T, class _Super>
	static Type<_T, _Super> Make(const _Super& super, const CesiumGltf::Model& model, const CesiumGltf::Accessor* accessor)
	{
		return Type<_T, _Super>{accessor ? CesiumGltf::AccessorView<_T>(model, *accessor): CesiumGltf::AccessorView<_T>(), super};
	}
};

namespace Types
{
struct Scalar;
struct Vec3;
struct Vec4;
} // namespace Type

using AllComponentTypes = boost::mpl::set<int8_t, uint8_t, int16_t, uint16_t, uint32_t, float>;

//! Describes the indices of a primitive.
template<class _T> struct Indices
{
	using ComponentTypes = boost::mpl::set<uint8_t, uint16_t, uint32_t>;
	using Types = boost::mpl::set<Types::Scalar>;
	_T indices_;
};
//! Describes the "feature ID" attribute of a primitive.
template<class _T> struct FeatureIds
{
	using ComponentTypes = AllComponentTypes;
	using Types = boost::mpl::set<Types::Scalar>;
	_T featureIds_;
};
//! Describes the "color" attribute of a primitive.
template<class _T> struct Colors
{
	using ComponentTypes = boost::mpl::set<uint8_t, uint16_t, float>;
	using Types = boost::mpl::set<Types::Vec3, Types::Vec4>;
	_T colors_;
};

} // namespace AccessorViews

//! Tells how primitive topologies are converted.
static int32_t GetConvertedPrimitiveMode(int32_t mode)
{
	switch (mode)
	{
		case CesiumGltf::MeshPrimitive::Mode::LINE_LOOP:
		case CesiumGltf::MeshPrimitive::Mode::LINE_STRIP:
			return CesiumGltf::MeshPrimitive::Mode::LINES;
		case CesiumGltf::MeshPrimitive::Mode::TRIANGLE_STRIP:
		case CesiumGltf::MeshPrimitive::Mode::TRIANGLE_FAN:
			return CesiumGltf::MeshPrimitive::Mode::TRIANGLES;
	}
	return mode;
}

//! Rules with additional precomputed derived data.
struct GltfTunerRulesEx: GltfTuner::Rules
{
	int version_ = 0; //! Used to detect if we should recompute derived data.
	//! Maps each element ID to the index of its containing group.
	std::unordered_map<uint64_t, size_t> elementToGroup_;
};

class GltfTunerHelper
{
public:
	//! See Cluster below.
	//! ClusterId is used as a key to identify in which cluster a piece (triangle etc.) should be added.
	struct ClusterId
	{
		int32_t material_ = -1;
		int32_t mode_ = CesiumGltf::MeshPrimitive::Mode::TRIANGLES;
		bool hasNormal_ = false;
		bool hasUV_ = false;
		bool hasColor_ = false;
		bool hasFeatureId_ = false;
		int elementGroupIndex_ = -1;
	};
	//! A cluster is a list of "pieces" (triangles, lines or points) that are grouped together.
	//! Eventually, for each cluster a primitive will be created.
	struct Cluster
	{
		std::vector<std::array<uint32_t, 1>> indices_;
		std::vector<std::array<float, 3>> positions_;
		std::vector<std::array<float, 3>> normals_;
		std::vector<std::array<float, 2>> uvs_;
		std::vector<std::array<uint8_t, 4>> colors_;
		std::vector<std::array<float, 1>> featureIds_;
	};
	using ClusterList = std::unordered_map<ClusterId, Cluster,
		decltype([](const auto& x){return boost::pfr::hash_fields(x);}),
		boost::pfr::equal_to<>>;
	const CesiumGltf::Model& model_; //!< The input model.
	const GltfTunerRulesEx& rules_;
	std::optional<CesiumGltf::AccessorView<uint64_t>> elementPropertyTableView_;
	GltfTunerHelper(const CesiumGltf::Model& model, const GltfTunerRulesEx& rules)
		:model_(model)
		,rules_(rules)
	{
	}
	CesiumGltf::Model Tune()
	{
		GltfBuilder gltfBuilder;
		// Look for the metadata (inside EXT_structural_metadata) generated by the mesh export service.
		int64_t propertyTableIndex;
		[&]
		{
			const auto* structuralMetadataExtension = model_.getExtension<CesiumGltf::ExtensionModelExtStructuralMetadata>();
			if (!structuralMetadataExtension)
				return;
			for (propertyTableIndex = 0; propertyTableIndex < (int)structuralMetadataExtension->propertyTables.size(); ++propertyTableIndex)
			{
				const auto& propertyTable = structuralMetadataExtension->propertyTables[propertyTableIndex];
				if (propertyTable.classProperty != "MeshPart")
					continue;
				const auto elementPropertyIt = propertyTable.properties.find("element");
				if (elementPropertyIt == propertyTable.properties.end())
					return;
				{
					const auto& elementBufferView = model_.bufferViews[elementPropertyIt->second.values];
					elementPropertyTableView_ = CesiumGltf::AccessorView<uint64_t>(
						model_.buffers[elementBufferView.buffer].cesium.data.data(),
						sizeof(uint64_t),
						elementBufferView.byteOffset,
						propertyTable.count);
				}
				// Copy the table information in the output model.
				// We do not copy all extensions, because extensions might reference data contained in buffers,
				// and we are building a new buffer from scratch, containing only what we need.
				// Thus we want to avoid having extensions that reference invalid accessors, buffers etc.
				auto& outExtension = gltfBuilder.GetModel().addExtension<CesiumGltf::ExtensionModelExtStructuralMetadata>();
				outExtension.schema = structuralMetadataExtension->schema;
				// Copy the table as it is. We are going to adjust the referenced buffer views just below.
				outExtension.propertyTables.push_back(propertyTable);
				// Transfer the actual table data to the ouput model's buffer.
				// To have reproducible output (which is neede for unit tests), we fill the buffer
				// by order of the property name (eg. "category", then "element, then "model").
				{
					std::vector<const decltype(propertyTable.properties)::value_type*> sortedProperties;
					for (const auto& property: propertyTable.properties)
						sortedProperties.push_back(&property);
					std::sort(sortedProperties.begin(), sortedProperties.end(),
						[](const auto& x, const auto& y){return x->first < y->first;});
					for (const auto* property: sortedProperties)
					{
						if (property->second.values == -1)
							continue;
						const auto& inBufferView = model_.bufferViews[property->second.values];
						auto& outBufferView = gltfBuilder.GetModel().bufferViews.emplace_back(inBufferView);
						outBufferView.buffer = 0;
						outBufferView.byteOffset = (int64_t)gltfBuilder.GetModel().buffers[0].cesium.data.size();
						gltfBuilder.GetModel().buffers[0].cesium.data.insert(
							gltfBuilder.GetModel().buffers[0].cesium.data.end(),
							model_.buffers[inBufferView.buffer].cesium.data.begin()+inBufferView.byteOffset,
							model_.buffers[inBufferView.buffer].cesium.data.begin()+inBufferView.byteOffset+inBufferView.byteLength);
						// Adjust the index of the buffer view referenced in the output table.
						outExtension.propertyTables[0].properties[property->first].values = (int32_t)gltfBuilder.GetModel().bufferViews.size()-1;
					}
				}
				break;
			}
		}();
		// Process the primitives of each mesh.
		// Note: we do not merge primitives belonging to different meshes,
		// since it would break the structure of the model's scene.
		for (const auto& mesh: model_.meshes)
		{
			ClusterList clusters;
			for (const auto& primitive: mesh.primitives)
			{
				// Look for the _FEATURE_ID_X corresponding to our metadata.
				const auto featureIdsAccessorIndex = [&]
					{
						if (!elementPropertyTableView_)
							return -1;
						const auto* extension = primitive.getExtension<CesiumGltf::ExtensionExtMeshFeatures>();
						if (!extension)
							return -1;
						int64_t attributeSuffix = -1;
						for (const auto& featureId: extension->featureIds)
						{
							if (featureId.propertyTable != propertyTableIndex)
								continue;
							if (!featureId.attribute)
								return -1;
							attributeSuffix = *featureId.attribute;
							break;
						}
						const auto attributeIt = primitive.attributes.find("_FEATURE_ID_"+std::to_string(attributeSuffix));
						return attributeIt == primitive.attributes.end() ? -1 : attributeIt->second;
					}();
				const auto colorAttributeIt = primitive.attributes.find("COLOR_0");
				// Process the primitive using typed accessors for data that can may have different types.
				// For example:
				// - indices may be UNSIGNED_BYTE, UNSIGNED_SHORT etc.
				// - colors may be VEC3 or VEC4.
				ProcessPrimitive(std::make_tuple(
					AccessorViews::Maker<AccessorViews::Indices>{primitive.indices},
					AccessorViews::Maker<AccessorViews::FeatureIds>{featureIdsAccessorIndex},
					AccessorViews::Maker<AccessorViews::Colors>{colorAttributeIt == primitive.attributes.end() ? -1 : colorAttributeIt->second}),
					primitive, clusters);
			}
			gltfBuilder.GetModel().meshes.emplace_back();
			// To have reproducible output (which is neede for unit tests), we add the primitives
			// by order of the cluster ID.
			std::vector<const decltype(clusters)::value_type*> sortedClusters;
			for (const auto& cluster: clusters)
				sortedClusters.push_back(&cluster);
			std::sort(sortedClusters.begin(), sortedClusters.end(),
				[](const auto& x, const auto& y){return boost::pfr::lt(x->first, y->first);});
			for (const auto* clusterEntry: sortedClusters)
			{
				const auto& clusterId = clusterEntry->first;
				const auto& cluster = clusterEntry->second;
				auto primitive = gltfBuilder.AddMeshPrimitive((int)gltfBuilder.GetModel().meshes.size()-1, clusterId.material_, clusterId.mode_);
				primitive.SetIndices(cluster.indices_, true);
				primitive.SetPositions(cluster.positions_);
				if (!cluster.normals_.empty())
					primitive.SetNormals(cluster.normals_);
				if (!cluster.uvs_.empty())
					primitive.SetUVs(cluster.uvs_);
				if (!cluster.colors_.empty())
					primitive.SetColors(cluster.colors_);
				if (!cluster.featureIds_.empty())
					primitive.SetFeatureIds(cluster.featureIds_);
			}
		}
		// Copy everything else from the input model.
		// We skip some properties (eg skins) because they may reference data contained in buffers,
		// and we are building a new buffer from scratch, containing only what we need.
		// Thus we want to avoid having properties that reference invalid accessors, buffers etc.
		gltfBuilder.GetModel().extras = model_.extras;
		gltfBuilder.GetModel().unknownProperties = model_.unknownProperties;
		gltfBuilder.GetModel().extensionsUsed = model_.extensionsUsed;
		gltfBuilder.GetModel().extensionsRequired = model_.extensionsRequired;
		gltfBuilder.GetModel().asset = model_.asset;
		gltfBuilder.GetModel().cameras = model_.cameras;
		gltfBuilder.GetModel().images = model_.images;
		gltfBuilder.GetModel().materials = model_.materials;
		gltfBuilder.GetModel().nodes = model_.nodes;
		gltfBuilder.GetModel().samplers = model_.samplers;
		gltfBuilder.GetModel().scene = model_.scene;
		gltfBuilder.GetModel().scenes = model_.scenes;
		gltfBuilder.GetModel().textures = model_.textures;
		return std::move(gltfBuilder.GetModel());
	}
private:
	//! This function recursively "builds" specialized versions ProcessPrimitive2,
	//! one for each combination of the given accessor views.
	//! One issue with this technique is that it can result in code bloat,
	//! So we have to make sure to skip combinations which we know are not valid
	//! (eg. FLOAT for indices, or SCALAR for colors etc).
	template<class _AccessorViewMakers, size_t _curIndex = 0, class _CurAccessorViews = AccessorViews::Empty>
	void ProcessPrimitive(const _AccessorViewMakers& accessorViewMakers, const CesiumGltf::MeshPrimitive& primitive, ClusterList& clusters, const _CurAccessorViews& accessorViews = {})
	{
		if constexpr (_curIndex == std::tuple_size<_AccessorViewMakers>::value)
		{
			// End of recursion, specialization complete.
			ProcessPrimitive2<_CurAccessorViews>(primitive, clusters, accessorViews);
		}
		else
		{
			const auto accessorIndex = std::get<_curIndex>(accessorViewMakers).index_;
			const auto* accessor = accessorIndex == -1 ? (CesiumGltf::Accessor*)nullptr : CesiumGltf::Model::getSafe(&model_.accessors, accessorIndex);
			using Maker = std::tuple_element_t<_curIndex, _AccessorViewMakers>;
			// Use a dummy view holder type, just to retrieve the supported data types.
			//using DummyViewHolder = Maker::ViewHolder<int>;
			const auto step1 = [&](auto* unusedComponentType)
				{
					using ComponentType = std::decay_t<decltype(*unusedComponentType)>;
					if constexpr (!boost::mpl::has_key< typename Maker::template ViewHolder<int>::ComponentTypes, ComponentType>::value)
						return;
					else
					{
						const auto step2 = [&](auto* unusedType)
							{
								using Type = std::decay_t<decltype(*unusedType)>;
								if constexpr (!boost::mpl::has_key<typename Maker::template ViewHolder<int>::Types, Type>::value)
									return;
								else
								{
									const auto step3 = [&](auto* unusedCompleteType)
										{
											ProcessPrimitive<_AccessorViewMakers, _curIndex+1>(accessorViewMakers, primitive, clusters,
												Maker::template Make<std::decay_t<decltype(*unusedCompleteType)>>(accessorViews, model_, accessor));
										};
									if constexpr (std::is_same_v<AccessorViews::Types::Scalar, Type>)
										step3((std::array<ComponentType, 1>*)0);
									else if constexpr (std::is_same_v<AccessorViews::Types::Vec3, Type>)
										step3((std::array<ComponentType, 3>*)0);
									else if constexpr (std::is_same_v<AccessorViews::Types::Vec4, Type>)
										step3((std::array<ComponentType, 4>*)0);
									else
										static_assert(std::is_void_v<Type>);
								}
							};
						if (!accessor)
						{
							// If there is no accessor in the model (eg. the primitive has no "color" attribute,
							// use the first supported type for this accessor.
							// This avoids generating useless code (even if it will be skipped early).
							step2((typename boost::mpl::front<typename Maker::template ViewHolder<int>::Types>::type*)0);
						}
						else if (accessor->type == CesiumGltf::Accessor::Type::SCALAR)
							step2((AccessorViews::Types::Scalar*)0);
						else if (accessor->type == CesiumGltf::Accessor::Type::VEC3)
							step2((AccessorViews::Types::Vec3*)0);
						else if (accessor->type == CesiumGltf::Accessor::Type::VEC4)
							step2((AccessorViews::Types::Vec4*)0);
						else
							return;
					}
				};
			if (!accessor)
			{
				// If there is no accessor in the model (eg. the primitive has no "color" attribute,
				// use the first supported component type for this accessor.
				// This avoids generating useless code (even if it will be skipped early).
				step1((typename boost::mpl::front<typename Maker::template ViewHolder<int>::ComponentTypes>::type*)0);
			}
			else
				switch (accessor->componentType)
				{
					case CesiumGltf::Accessor::ComponentType::BYTE:           step1((int8_t*)0);   break;
					case CesiumGltf::Accessor::ComponentType::UNSIGNED_BYTE:  step1((uint8_t*)0);  break;
					case CesiumGltf::Accessor::ComponentType::SHORT:          step1((int16_t*)0);  break;
					case CesiumGltf::Accessor::ComponentType::UNSIGNED_SHORT: step1((uint16_t*)0); break;
					case CesiumGltf::Accessor::ComponentType::UNSIGNED_INT:   step1((uint32_t*)0); break;
					case CesiumGltf::Accessor::ComponentType::FLOAT:          step1((float*)0);    break;
					default:
						return;
				}
		}
	}
	template<class _AccessorViews>
	void ProcessPrimitive2(const CesiumGltf::MeshPrimitive& primitive, ClusterList& clusters, const _AccessorViews& accessorViews)
	{
		// Retrieve the accesor views for attributes having fixed data type.
		const CesiumGltf::AccessorView<std::array<float, 3>> positions(model_, primitive.attributes.find("POSITION")->second);
		const auto getView = [&](const std::string& attributeName, auto* unusedType)
			{
				const auto it = primitive.attributes.find(attributeName);
				using View = CesiumGltf::AccessorView<std::decay_t<decltype(*unusedType)>>;
				return it == primitive.attributes.end() ? View() : View(model_, it->second);
			};
		const auto normals = getView("NORMAL", (std::array<float, 3>*)0);
		const auto uvs = getView("TEXCOORD_0", (std::array<float, 2>*)0);
		// A vertex can be referenced by multiple indices (that's the purpose of the index buffer).
		// So once a vertex has been processed (ie. add to a cluster), we record its position inside the cluster's vertices.
		std::vector<int> newIndices(positions.size(), -1);
		// This function processes one "piece" (triangle, line...)
		const auto processPiece = [&](const auto& indexIndices)
			{
				// Get the element ID from the first vertex.
				// We assume all the vertices of this piece have the same element ID.
				const auto elementId = accessorViews.featureIds_.status() == CesiumGltf::AccessorViewStatus::Valid ?
					(*elementPropertyTableView_)[accessorViews.featureIds_[accessorViews.indices_[indexIndices[0]][0]][0]] :
					0;
				// Find the group (in the rules) that contains this element ID, if any.
				const auto groupIt = rules_.elementToGroup_.find(elementId);
				// Find the cluster where this piece will be added.
				auto& cluster = clusters[ClusterId{
					// For the material:
					// - if the element ID is in a group, use this group's material,
					// - otherwise, use the material of the primitive.
					groupIt == rules_.elementToGroup_.end() ? primitive.material :
						rules_.elementGroups_[groupIt->second].material_,
					GetConvertedPrimitiveMode(primitive.mode),
					normals.status() == CesiumGltf::AccessorViewStatus::Valid,
					uvs.status() == CesiumGltf::AccessorViewStatus::Valid,
					accessorViews.colors_.status() == CesiumGltf::AccessorViewStatus::Valid,
					accessorViews.featureIds_.status() == CesiumGltf::AccessorViewStatus::Valid,
					groupIt == rules_.elementToGroup_.end() ? -1 : (int)groupIt->second}];
				for (const auto indexIndex: indexIndices)
				{
					const auto index = accessorViews.indices_[indexIndex][0];
					if (newIndices[index] == -1)
					{
						cluster.positions_.push_back(positions[index]);
						if (normals.status() == CesiumGltf::AccessorViewStatus::Valid)
							cluster.normals_.push_back(normals[index]);
						if (uvs.status() == CesiumGltf::AccessorViewStatus::Valid)
							cluster.uvs_.push_back(uvs[index]);
						if (accessorViews.colors_.status() == CesiumGltf::AccessorViewStatus::Valid)
							cluster.colors_.push_back([&]
								{
									// Convert color to VEC4<UNSIGNED_BYTE>.
									using InputColor = typename decltype(accessorViews.colors_)::value_type;
									// First, convert each component to UNSIGNED_BYTE,
									// keeping the same dimension (VEC3 or VEC4) as the input color.
									const auto color = [&]()->std::array<uint8_t, std::tuple_size_v<InputColor>>
										{
											const auto& color = accessorViews.colors_[index];
											if constexpr (std::is_same_v<uint8_t, typename InputColor::value_type>)
												return color;
											else if constexpr (std::is_same_v<uint16_t, typename InputColor::value_type>)
											{
												std::array<uint8_t, std::tuple_size_v<InputColor>> color2;
												for (auto c = 0; c < color.size(); ++c)
													color2[c] = uint8_t(color[c]>>8);
												return color2;
											}
											else if constexpr (std::is_same_v<float, typename InputColor::value_type>)
											{
												std::array<uint8_t, std::tuple_size_v<InputColor>> color2;
												for (auto c = 0; c < color.size(); ++c)
													color2[c] = std::min((uint8_t)255, uint8_t(color[c]*256));
												return color2;
											}
											else
												static_assert(std::is_void_v<InputColor>);
										}();
									// Now, adjust the dimension if needed.
									return [&]()->std::array<uint8_t, 4>
										{
											if constexpr (std::tuple_size_v<InputColor> == 3)
												return {color[0], color[1], color[2], 0xff};
											else if constexpr (std::tuple_size_v<InputColor> == 4)
												return color;
											else
												static_assert(std::is_void_v<InputColor>);
										}();
								}());
						if (accessorViews.featureIds_.status() == CesiumGltf::AccessorViewStatus::Valid)
							cluster.featureIds_.push_back({(float)accessorViews.featureIds_[index][0]});
						// Record the position of this vertex inside its cluster.
						newIndices[index] = (int)cluster.positions_.size()-1;
					}
					cluster.indices_.push_back({(uint32_t)newIndices[index]});
				}
			};
		// Process each piece, depending on the primitive topology.
		// The indices to use for triangle strips etc are specified here:
		// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview.
		switch (primitive.mode)
		{
			case CesiumGltf::MeshPrimitive::Mode::POINTS:
				for (auto pieceIndex = 0; pieceIndex < accessorViews.indices_.size(); ++pieceIndex)
					processPiece(std::to_array({pieceIndex}));
				break;
			case CesiumGltf::MeshPrimitive::Mode::LINES:
				for (auto pieceIndex = 0; pieceIndex < accessorViews.indices_.size()/2; ++pieceIndex)
					processPiece(std::to_array({2*pieceIndex, 2*pieceIndex+1}));
				break;
			case CesiumGltf::MeshPrimitive::Mode::LINE_LOOP:
				for (auto pieceIndex = 0; pieceIndex < accessorViews.indices_.size(); ++pieceIndex)
					processPiece(std::to_array({pieceIndex, (pieceIndex+1)%(int)accessorViews.indices_.size()}));
				break;
			case CesiumGltf::MeshPrimitive::Mode::LINE_STRIP:
				for (auto pieceIndex = 0; pieceIndex < accessorViews.indices_.size()-1; ++pieceIndex)
					processPiece(std::to_array({pieceIndex, pieceIndex+1}));
				break;
			case CesiumGltf::MeshPrimitive::Mode::TRIANGLES:
				for (auto pieceIndex = 0; pieceIndex < accessorViews.indices_.size()/3; ++pieceIndex)
					processPiece(std::to_array({3*pieceIndex, 3*pieceIndex+1, 3*pieceIndex+2}));
				break;
			case CesiumGltf::MeshPrimitive::Mode::TRIANGLE_STRIP:
				for (auto pieceIndex = 0; pieceIndex < accessorViews.indices_.size()-2; ++pieceIndex)
					processPiece(std::to_array({pieceIndex, pieceIndex+1+pieceIndex%2, pieceIndex+2-pieceIndex%2}));
				break;
			case CesiumGltf::MeshPrimitive::Mode::TRIANGLE_FAN:
				for (auto pieceIndex = 0; pieceIndex < accessorViews.indices_.size()-2; ++pieceIndex)
					processPiece(std::to_array({pieceIndex+1, pieceIndex+2, 0}));
				break;
		}
	}
};

} // unnamed namespace

class GltfTuner::Impl
{
public:
	Rules rules_;
	int rulesVersion_ = 0; //! Used to detect if we should recompute rules derived data.
	GltfTunerRulesEx rulesEx_;
	// Tune() and SetRules() can be called by different threads
	// (typically Tune() is called on a background thread),
	// so we have to protect access to data used by both methods.
	std::mutex mutex_;
};

GltfTuner::GltfTuner()
	:impl_(new Impl())
{
}

GltfTuner::~GltfTuner()
{
}

CesiumGltf::Model GltfTuner::Tune(const CesiumGltf::Model& model)
{
	// Test if we should recompute rules derived data.
	bool isRulesExOutdated = false;
	{
		std::scoped_lock lock(impl_->mutex_);
		if (impl_->rulesVersion_ > impl_->rulesEx_.version_)
		{
			isRulesExOutdated = true;
			impl_->rulesEx_.version_ = impl_->rulesVersion_;
			(Rules&)impl_->rulesEx_ = impl_->rules_;
		}
	}
	if (isRulesExOutdated)
	{
		impl_->rulesEx_.elementToGroup_.clear();
		for (auto groupIndex = 0; groupIndex < impl_->rulesEx_.elementGroups_.size(); ++groupIndex)
			for (const auto elementId: impl_->rulesEx_.elementGroups_[groupIndex].elements_)
				impl_->rulesEx_.elementToGroup_[elementId] = groupIndex;
	}
	return GltfTunerHelper(model, impl_->rulesEx_).Tune();
}

void GltfTuner::SetRules(Rules&& rules)
{
	// Here we do not test if the new rules actually differ from the current ones.
	// For now we assume it is the responsibility of the caller to call this only when needed.
	std::scoped_lock lock(impl_->mutex_);
	impl_->rules_ = std::move(rules);
	++impl_->rulesVersion_;
}

} // namespace BeUtils
