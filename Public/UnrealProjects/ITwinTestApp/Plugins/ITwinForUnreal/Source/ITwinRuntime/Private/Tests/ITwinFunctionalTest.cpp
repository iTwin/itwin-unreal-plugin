/*--------------------------------------------------------------------------------------+
|
|     $Source: ITwinFunctionalTest.cpp $
|
|  $Copyright: (c) 2025 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/

#include "ITwinFunctionalTest.h"
#if WITH_EDITOR
#include <FunctionalTest.h>
#include <FunctionalTestBase.h>
#include <AutomationScreenshotOptions.h>
#include <Tests/AutomationCommon.h>
#include <AutomationBlueprintFunctionLibrary.h>
#include <FunctionalTestingModule.h>
#include <FileHelpers.h>
#include <FunctionalTestingHelper.h>
#include <Interfaces/IScreenShotToolsModule.h>
#include <IAutomationControllerModule.h>
#include <Interfaces/IPluginManager.h>
#endif // WITH_EDITOR

#if WITH_EDITOR

namespace ITwin::Tests::Detail
{

class FFunctionalTestExecInfo
{
public:
	FAutomationTestExecutionInfo Exec;
	std::vector<FString> ScreenshotNames;
};

class FFunctionalStaticData
{
public:
	TMap<FString, FFunctionalTestImpl> Tests;
	FDelegateHandle OnTestCompleteHandle;
	TMap<FString, FFunctionalTestExecInfo> ExecInfos;

};

auto& GetFunctionalStaticData()
{
	static FFunctionalStaticData Data;
	return Data;
}

void RegisterFunctionalTest(const FString& Name, const FFunctionalTestImpl& Test)
{
	GetFunctionalStaticData().Tests.Add(Name, Test);
}

//! Returns the directory where all "result" files are gathered for ADO report.
FString GetResultsFinalDir()
{
	return FPaths::ProjectIntermediateDir()/TEXT("ITwinFunctionalTests");
}

} // namespace ITwin::Tests::Detail

#endif // WITH_EDITOR

class AITwinFunctionalTestStarter::FImpl
{
public:
#if WITH_EDITOR
	ITwin::Tests::Detail::FFunctionalTestImpl TestImpl;
	AFunctionalTest* TestActor = nullptr;
#endif // WITH_EDITOR
};

AITwinFunctionalTestStarter::AITwinFunctionalTestStarter()
	:Impl(MakePimpl<FImpl>())
{
}

void AITwinFunctionalTestStarter::StartTest()
{
#if WITH_EDITOR
	// Disable "treat warning logs as errors", other wise warnings will make the test fail.
	static_cast<FFunctionalTestBase*>(FAutomationTestFramework::Get().GetCurrentTest())->SetLogErrorAndWarningHandling({}, {}, false);
	Impl->TestImpl(GetWorld()).ContinueWith([this]
		{
			Impl->TestActor->FinishTest(EFunctionalTestResult::Succeeded, TEXT("Test finished"));
			// Record the test execution infos (error messages etc).
			FAutomationTestFramework::Get().GetCurrentTest()->GetExecutionInfo(
				ITwin::Tests::Detail::GetFunctionalStaticData().ExecInfos.FindOrAdd(FAutomationTestFramework::Get().GetCurrentTest()->GetTestContext()).Exec);
		});
#else // WITH_EDITOR
	// This class is never instantiated in non-editor build.
	check(false);
#endif // WITH_EDITOR
}

#if WITH_EDITOR

namespace ITwin::Tests
{

UE5Coro::TCoroutine<> TakeScreenshot(const FString Name)
{
	// Use a small margin to account for "low" resolution of file time stamps.
	const auto BeforeScreenshotDate = FDateTime::UtcNow()-FTimespan::FromSeconds(1);
	TPromise<void> Promise;
	FAutomationScreenshotOptions Options;
	// TODO_AW configure options (resolution, tolerance...)
	Options.Resolution = {640, 360}; // Use low resolution to avoid bloating ADO.
	const auto DelegateHandle = FAutomationTestFramework::Get().OnScreenshotTakenAndCompared.AddLambda([&]()
		{
			UE_LOG(LogFunctionalTest, Display, TEXT("OnScreenshotTakenAndCompared, now = %lld"), FDateTime::UtcNow().GetTicks());
			Promise.SetValue();
		});
	auto* const World = AutomationCommon::GetAnyGameWorld();
	UE_LOG(LogFunctionalTest, Display, TEXT("Before TakeAutomationScreenshot, now = %lld"), FDateTime::UtcNow().GetTicks());
	UAutomationBlueprintFunctionLibrary::TakeAutomationScreenshot(World, {-1, -1, nullptr, World}, Name, {}, Options);
	UE_LOG(LogFunctionalTest, Display, TEXT("Before co_await, now = %lld"), FDateTime::UtcNow().GetTicks());
	co_await Promise.GetFuture();
	UE_LOG(LogFunctionalTest, Display, TEXT("After co_await, now = %lld"), FDateTime::UtcNow().GetTicks());
	FAutomationTestFramework::Get().OnScreenshotTakenAndCompared.Remove(DelegateHandle);
	// Move the scrennshot files to the final directory.
	FModuleManager::LoadModuleChecked<IScreenShotToolsModule>("ScreenShotComparisonTools").GetScreenShotManager()->
		ExportScreenshotComparisonResult(TEXT("Functional")/Name, Detail::GetResultsFinalDir());
	// The screenshot folder generated by UE may have various intermediate dir names (eg. "Windows/D3D12_SM6").
	// So here we look for the screenshot file that has been generated just now. There should be only one.
	// Also, ADO wants unique name for each screenshot file (if several files have same but located in different folders,
	// then ADO will only show one of them). So we rename the files.
	[&]
	{
		TArray<FString> ScreenshotFiles;
		IFileManager::Get().FindFilesRecursive(ScreenshotFiles, *(Detail::GetResultsFinalDir()/TEXT("Functional")/Name), TEXT("Incoming.png"), true, false);
		UE_LOG(LogFunctionalTest, Display, TEXT("ScreenshotFiles num = %d"), ScreenshotFiles.Num());
		UE_LOG(LogFunctionalTest, Display, TEXT("BeforeScreenshotDate = %lld"), BeforeScreenshotDate.GetTicks());
		for (const auto& ScreenshotFile: ScreenshotFiles)
			UE_LOG(LogFunctionalTest, Display, TEXT("Found screenshot file \"%s\", timestamp = %lld"), *ScreenshotFile, IFileManager::Get().GetTimeStamp(*ScreenshotFile).GetTicks());
		ScreenshotFiles = ScreenshotFiles.FilterByPredicate([&](const auto& X){return IFileManager::Get().GetTimeStamp(*X) >= BeforeScreenshotDate;});
		if (ScreenshotFiles.Num() != 1)
		{
			// Zero or several files are found. Report an error.
			FAutomationTestFramework::Get().GetCurrentTest()->AddError(FString::Format(TEXT("Found {0} screenshot files for {1}"), {ScreenshotFiles.Num(), Name}));
			return;
		}
		// Give unique name to screenshot files (actual, ref, diff).
		IFileManager::Get().Move(*(Detail::GetResultsFinalDir()/(Name+TEXT(".png"))), *ScreenshotFiles[0], true, false, false, true);
		IFileManager::Get().Move(*(Detail::GetResultsFinalDir()/(Name+TEXT("_Ref.png"))), *(ScreenshotFiles[0]/TEXT("../Approved.png")), true, false, false, true);
		IFileManager::Get().Move(*(Detail::GetResultsFinalDir()/(Name+TEXT("_Diff.png"))), *(ScreenshotFiles[0]/TEXT("../Delta.png")), true, false, false, true);
		Detail::GetFunctionalStaticData().ExecInfos.FindOrAdd(FAutomationTestFramework::Get().GetCurrentTest()->GetTestContext()).
			ScreenshotNames.push_back(Name);
	}();
	// Wait one tick for the FLatentActionManager to remove the screenshot action,
	// otherwise next screenshot request may be ignored.
	co_await UE5Coro::Latent::NextTick();
}

} // namespace ITwin::Tests

IMPLEMENT_CUSTOM_COMPLEX_AUTOMATION_TEST(FITwinFunctionalTest, FFunctionalTestBase, "Bentley.ITwinForUnreal.ITwinRuntime.Functional", EAutomationTestFlags::EditorContext | EAutomationTestFlags::EngineFilter)

void FITwinFunctionalTest::GetTests(TArray<FString>& OutBeautifiedNames, TArray<FString>& OutTestCommands) const
{
	// Retrieve all registered functional tests.
	for (const auto& [Name, Impl]: ITwin::Tests::Detail::GetFunctionalStaticData().Tests)
	{
		OutBeautifiedNames.Add(Name);
		OutTestCommands.Add(Name);
	}
}

bool FITwinFunctionalTest::RunTest(const FString& Parameters)
{
	// If this is the first functional test that is executed in this session, register a callback
	// to generate the xml report when session is complete.
	if (!ITwin::Tests::Detail::GetFunctionalStaticData().OnTestCompleteHandle.IsValid())
	{
		ITwin::Tests::Detail::GetFunctionalStaticData().ExecInfos.Empty();
		ITwin::Tests::Detail::GetFunctionalStaticData().OnTestCompleteHandle =
			FModuleManager::LoadModuleChecked<IAutomationControllerModule>(TEXT("AutomationController")).GetAutomationController()->OnTestsComplete().
			AddLambda([]
				{
					// Unregister this callback.
					FModuleManager::LoadModuleChecked<IAutomationControllerModule>(TEXT("AutomationController")).GetAutomationController()->OnTestsComplete().
						Remove(ITwin::Tests::Detail::GetFunctionalStaticData().OnTestCompleteHandle);
					ITwin::Tests::Detail::GetFunctionalStaticData().OnTestCompleteHandle.Reset();
					// Generate xml report.
					FString Xml;
					Xml += TEXT("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
					Xml += TEXT("<testsuites>\n");
					// Prefix test suite name with target/platform/config, to distinguish reports on ADO.
					Xml += FString::Format(TEXT("<testsuite name=\"ITwinFunctional_{0}_{1}_{2}\">\n"),
						{FPlatformMisc::GetUBTTargetName(), FPlatformMisc::GetUBTPlatform(), FModuleManager::GetUBTConfiguration()});
					for (const auto& [TestName, ExecInfo]: ITwin::Tests::Detail::GetFunctionalStaticData().ExecInfos)
					{
						Xml += FString::Format(TEXT("<testcase name=\"{0}\">\n"), {TestName});
						// JUnit schema only allows one failure per test, so we join all error messages.
						if (ExecInfo.Exec.GetErrorTotal() > 0)
						{
							TArray<FString> ErrorMessages;
							for (const auto& Entry: ExecInfo.Exec.GetEntries())
								if (Entry.Event.Type == EAutomationEventType::Error)
									ErrorMessages.Add(Entry.Event.Message);
							Xml += FString::Format(TEXT("<failure message=\"{0}\"/>\n"), {FString::Join(ErrorMessages, TEXT(" *** "))});
						}
						Xml += TEXT("<system-out>\n");
						for (const auto& ScreenshotName: ExecInfo.ScreenshotNames)
						{
							Xml += FString::Format(TEXT("[[ATTACHMENT|{0}.png]]\n"), {ScreenshotName});
							Xml += FString::Format(TEXT("[[ATTACHMENT|{0}_Ref.png]]\n"), {ScreenshotName});
							Xml += FString::Format(TEXT("[[ATTACHMENT|{0}_Diff.png]]\n"), {ScreenshotName});
						}
						Xml += TEXT("</system-out>\n");
						Xml += TEXT("</testcase>\n");
					}
					Xml += TEXT("</testsuite>\n");
					Xml += TEXT("</testsuites>\n");
					FFileHelper::SaveStringToFile(Xml, *(ITwin::Tests::Detail::GetResultsFinalDir()/TEXT("Results.xml")), FFileHelper::EEncodingOptions::ForceUTF8WithoutBOM);
				});
		IFileManager::Get().DeleteDirectory(*ITwin::Tests::Detail::GetResultsFinalDir(), false, true);
	}
	// The code below is inspired by UE's FClientFunctionalTestingMapsBase.RunTest.
	IFunctionalTestingModule::Get().MarkPendingActivation();
	// Create new empty map and save it.
	const auto MapPath = IPluginManager::Get().FindPlugin(TEXT("ITwinForUnreal"))->GetBaseDir()/TEXT("Content/Temp/Functional.umap");
	if (!FEditorFileUtils::SaveMap(UEditorLoadingAndSavingUtils::NewBlankMap(false), MapPath))
	{
		UE_LOG(LogFunctionalTest, Error, TEXT("Failed to create map \"%s\""), *MapPath);
		return false;
	}
	// Open the map generated above.
	// Ideally we would just create the map in memory without the need to save & load it,
	// but a lot of mandatory initialization/setup tasks are done by SaveMap() & AutomationOpenMap(),
	// and it is not straightforward to implement these tasks manually on an in-memory map.
	const auto MapName = TEXT("/ITwinForUnreal/Temp/Functional");
	if (!AutomationOpenMap(MapName))
	{
		UE_LOG(LogFunctionalTest, Error, TEXT("Failed to open map \"%s\""), MapName);
		return false;
	}
	// Add a FunctionalTest actor, implementing all the boilerplate stuff needed (creating a viewport etc).
	// Also, see doc of AITwinFunctionalTestStarter for why we instantiate it.
	FActorSpawnParameters SpawnParams;
	SpawnParams.Name = FName(Parameters);
	auto* const TestActor = AutomationCommon::GetAnyGameWorld()->SpawnActor<AFunctionalTest>(SpawnParams);
	auto* const TestStarter = AutomationCommon::GetAnyGameWorld()->SpawnActor<AITwinFunctionalTestStarter>();
	TestStarter->Impl->TestImpl = ITwin::Tests::Detail::GetFunctionalStaticData().Tests[Parameters];
	TestStarter->Impl->TestActor = TestActor;
	TestActor->OnTestStart.AddDynamic(TestStarter, &AITwinFunctionalTestStarter::StartTest);
	// Start the real test (ie. user code).
	ADD_LATENT_AUTOMATION_COMMAND(FStartFTestOnMap(Parameters));
	return true;
}

#endif // WITH_EDITOR
