uint _czm_width;
uint _czm_height;
uint _czm_pixelX;
uint _czm_pixelY;
bool _czm_knownXY = false;
uint _czm_featureIndex = round(FeatureID);
Synchro4D_RGBA_DATA.GetDimensions(_czm_width, _czm_height);
_czm_pixelY = _czm_featureIndex / _czm_width;
// Second clause added for robustness, in case one wants to test manually with dummy textures,
// BUT ALSO to handle error cases where FeatureID is invalid in the Cesium tile
if (_czm_width == 1 || _czm_pixelY >= _czm_height)
{
	Combined_RGBA = float4(0, 0, 0, 1);
}
else
{
	_czm_knownXY = true;
	_czm_pixelX = _czm_featureIndex % _czm_width;
	Combined_RGBA = Synchro4D_RGBA_DATA.Load(int3(_czm_pixelX, _czm_pixelY, 0));
}
Synchro4D_CutPlanes_DATA.GetDimensions(_czm_width, _czm_height);
if (_czm_width != 1 && !_czm_knownXY)
{
	_czm_pixelX = _czm_featureIndex % _czm_width;
	_czm_pixelY = _czm_featureIndex / _czm_width;
}

// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //
//                                 !!! IMPORTANT !!!
// When you edit this file, change also the shader script inside the MLB_ITwinBlend
// node named "Get Synchro4D and selection Values per Feature" (see comment there), otherwise
// Unreal (5.3) may reuse a precompiled shader cache...
// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //


// Last two clauses added for robustness, in case one wants to test manually with dummy textures
// (even _czm_pixelX might be >= _czm_width if for some reason the CutPlane texture does not have
//  the same size as the RGBA one)
// BUT ALSO to handle error cases where FeatureID is invalid in the Cesium tile
if (_czm_width == 1 || _czm_pixelX >= _czm_width || _czm_pixelY >= _czm_height)
{
	Synchro4D_CutPlane = float4(0, 0, 0, 0);
}
else
{
	Synchro4D_CutPlane = Synchro4D_CutPlanes_DATA.Load(int3(_czm_pixelX, _czm_pixelY, 0));
}

// Now handle the Selection_RGBA_DATA input (aka "SelectingAndHiding" in the C++ code):
// Synchro4D color and partial or zero opacity have priority, unless Selection_RGBA_DATA's
// opacity is set to zero (Element is hidden)
Selection_RGBA_DATA.GetDimensions(_czm_width, _czm_height);
if (_czm_width != 1 && !_czm_knownXY)
{
	_czm_pixelX = _czm_featureIndex % _czm_width;
	_czm_pixelY = _czm_featureIndex / _czm_width;
}
// 0 = use only BaseColor (no 4D nor Selection highlight), 1 = use none of the BaseColor
// intermediate values used to blink between Selection/BaseColor when not done below between Selection/4D
float BaseColorBlendRatio = 0.;
if (_czm_width != 1 && _czm_pixelY < _czm_height)
{
	float4 SelecHideRGBA = Selection_RGBA_DATA.Load(int3(_czm_pixelX, _czm_pixelY, 0));
	bool bSelected = (SelecHideRGBA.x + SelecHideRGBA.y + SelecHideRGBA.z) != 0;
	// No 4D color nor custom opacity => use both color and opacity from Selection_RGBA_DATA
	if ((Combined_RGBA.x + Combined_RGBA.y + Combined_RGBA.z) == 0
		&& Combined_RGBA.w >= 0.98)
	{
		Combined_RGBA = SelecHideRGBA;
		// Note: this will also blink hidden Elements into visibility, which sounds a good idea
		// when they are selected by some other mean
		if (bSelected)
			BaseColorBlendRatio = BlinkingFactor; // Don't blink alpha, material may be opaque...
	}
	else
	{
		BaseColorBlendRatio = 1.; // Use none of the base color
		// When selected, blink between Selection and 4D:
		if (bSelected)
		{
			Combined_RGBA.xyz *= (1. - BlinkingFactor);
			Combined_RGBA.xyz += BlinkingFactor * SelecHideRGBA.xyz;
		}
		// Still need to account for hiding of Elements through Selection_RGBA_DATA's alpha:
		else if (SelecHideRGBA.w == 0)
		{
			Combined_RGBA.w = 0;
		}
	}
	if (bSelected && SelecHideRGBA.w == 0)
		Combined_RGBA.w = BlinkingFactor;
}
return BaseColorBlendRatio;